---
title: "Analysis_2025"
author: "M. Marzonie" "M. White"
date: "25/04/2025"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load Data

### Load Libraries

```{r, warning = FALSE, echo = FALSE, message=FALSE}
library(ggsci)
library(tidyverse)
library(dplyr) #not sure needed bc included in tidyverse
library(forcats) #not sure needed bc included in tidyverse
library(reshape2)
library(stringr)#not sure needed bc included in tidyverse
library(tidyr) #not sure needed bc included in tidyverse
library(tibble) #not sure needed bc included in tidyverse
library(sangerseqR)
library(DECIPHER)
library(Biostrings)
library(phangorn)
library(ape)
library(ggplot2)
library(ggtree)
library(patchwork)
library(bioseq)
library(kmer)
library(GUniFrac)
library(seqinr)
library(vegan)
library(corrplot)
library(ggrepel)

library(ggmsa)
library(dendextend)
library(usedist)
```


### Load Symbiont Data
```{r, show_col_types = FALSE}
seqs_monti <- read_tsv("seqs.abs.monti.txt") %>% 
    filter(!(is.na(sample_name))) %>%
  dplyr::select(sample_name, `A1`:`G3ai`) %>% 
  mutate(sample_name = as.factor(sample_name)) %>% 
  filter(!grepl("-20", sample_name) & !grepl("b", sample_name))


seqs_iso <- read_tsv("seqs.abs.Isopora.txt") %>% 
    filter(!(is.na(sample_name))) %>%
  dplyr::select(sample_name, `A1`:`G3ai`) %>% 
  mutate(sample_name = as.factor(sample_name)) %>% 
  filter(!grepl("-20", sample_name) & !grepl("b", sample_name))


seqs_acro <- read_tsv("seqs.abs.acro.txt") %>% 
    filter(!(is.na(sample_name))) %>%
  dplyr::select(sample_name, `A1`:`G3ai`) %>% 
  mutate(sample_name = as.factor(sample_name)) %>% 
  filter(!grepl("-20", sample_name) & !grepl("b", sample_name))

```


### Load Metadata

```{r}
library(readxl)
#Vial is the unique genotype for each coral sample. 
CoralSea2024_Metadata <- read_excel("CoralSea2024_Metadata.xlsx")

meta <- CoralSea2024_Metadata %>% 
  rename("VialID" = "sample_name",
         "Depth (m)"= "Depth")
```


### Load Custom Functions
```{r}
read_fasta_df <- function (file = "") {
  fasta <- readLines(file)
  ind <- grep(">", fasta)
  s <- data.frame(ind = ind, from = ind + 1, to = c((ind - 
    1)[-1], length(fasta)))
  seqs <- rep(NA, length(ind))
  for (i in 1:length(ind)) {
    seqs[i] <- paste(fasta[s$from[i]:s$to[i]], collapse = "")
  }
  tib <- tibble(label = gsub(">", "", fasta[ind]), sequence = seqs)
  return(tib)
}

write_fasta_df <- function (data, filename) 
{
    fastaLines = c()
    for (rowNum in 1:nrow(data)) {
        fastaLines = c(fastaLines, as.character(paste(">", 
            data[rowNum, "label"], sep = "")))
        fastaLines = c(fastaLines, as.character(data[rowNum, 
            "sequence"]))
    }
    fileConn <- file(filename)
    writeLines(fastaLines, fileConn)
    close(fileConn)
}

dna_to_DNAbin <- function (dna){
  DNAbin <- as_DNAbin(dna)
  names(DNAbin) <- names(dna)
  return(DNAbin)
}
dna_to_DNAStringset <- function(x) 
{
    bioseq:::check_dna(x)
    DNAstr <- DNAStringSet(paste(x))
    names(DNAstr) <- names(x)
    return(DNAstr)
}

DNAStringSet_to_dna <- function(x){
    x_dna <- as_dna(paste(x))
    names(x_dna) <- names(x)
    res <- tibble(label = names(x), sequence = x_dna)
    return(res)
}

# Convert DNAstringset to DNAbin
DNAStringSet_to_DNAbin <- function(DNAStringSet){
  DNAbin <- as.DNAbin(DNAStringSet)
  return(DNAbin)
}

# https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-018-2315-y
palette <- c("A" = "#46ff2d", 
             "G" = "#ffae01", 
             "C" = "#f24641", 
             "T" = "#4294fa", 
             "K" = "#8b4816",
             "M" = "#83831f",
             "R" = "#ffff81",
             "S" = "#ff9d80",
             "Y" = "#e381f2",
             "W" = "#80fff2",
             "V" = "#fde4b8",
             "B" = "#f9c1bf",
             "H" = "#c0d9f9",
             "D" = "#c7ffba",
             "U" = "#8989fb",
             "N" = "black", 
             "-" = "white",
             "+" = "White")


pal_df <- data.frame(names = names(palette), col = palette)
```

### Combining sequence/metadata 

## Loading Montipora Data

```{r}
# Convert to long format
seqs_long_monti <- seqs_monti %>%
  filter(!is.na(sample_name)) %>%
  select(sample_name, `A1`:`G3ai`) %>%
  pivot_longer(`A1`:`G3ai`) %>%
  filter(value > 0) %>% # Remove zero values
  left_join(., meta)

# Q. Are we working with the post-med seqs according to the metadata in seqs?
san_check_monti <- seqs_long_monti %>%
  group_by(sample_name) %>%
  summarise(total = sum(value)) #A. yes

# Create a list of samples to keep that didnt fail to sequence
keepers_ss <- san_check_monti %>%
  filter(total > 1500)

non_keep <- san_check_monti %>% 
  filter(total < 1500)

#we filter out 0 samples

# Filter out the failed samples (Not required for Montipora)
seqs_long_monti <- seqs_long_monti %>%
  filter(sample_name %in% keepers_ss$sample_name) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) %>% # Convert to relative abundance
  ungroup() %>%
  mutate(name = as.factor(name)) # Make sample names a factor

# Create a random palette for each sequence
n <- length(levels(seqs_long_monti$name))
seqs_pal = rainbow(n, s=.6, v=.9)[sample(1:n,n, replace = FALSE)]
names(seqs_pal) <- levels(seqs_long_monti$name)

# Read in the profile data
profiles_raw_monti <- read_tsv("profiles.abs.monti.txt", skip = 6) %>%
    select(sample_name = `...2`, `A1-A1qd-A1qe`:`G3fd`) %>%
    filter(!is.na(sample_name)) %>%
  select(sample_name, `A1-A1qd-A1qe`:`G3fd`)

#Convert to long format 
profiles_long_monti <- profiles_raw_monti %>%
  pivot_longer(`A1-A1qd-A1qe`:`G3fd`) %>% # Convert it to long format
  mutate(name = paste0("p_", name)) %>% # Add a p_ to the beginning of each profile (Some profiles are single sequence profiles and clash with the Sequence names)
  filter(sample_name %in% seqs_long_monti$sample_name) %>% # Remove samples that dont appear in the Sequence dataframe
  group_by(sample_name) %>%
  mutate(value = as.numeric(value)) %>%
  filter(value > 0) %>% # Remove 0 abundance profiles
  mutate(sample_name = as.factor(sample_name),
         name = as.factor(name)) %>% 
  ungroup() %>%
  left_join(., meta) # Add in metadata

# What is the total number of profile-related sequences in each sample?
profiles_sum_monti <- profiles_long_monti %>%
  group_by(sample_name) %>%
  summarise(total = sum(value))

# How many sequences in each sample are not part of a profile?
residual_monti <- left_join(profiles_sum_monti, san_check_monti, by = "sample_name") %>%
  mutate(residual = total.y - total.x) %>%
  select(sample_name, value = residual) %>%
  mutate(name = "non-profile sequences") %>%
  left_join(., meta)

# Combine the profiles and non-profile sequences
profile_data_monti <- rbind(profiles_long_monti, residual_monti) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) # convert to relative abundance - in that sample 

# Create palette for profiles (this is a darker palette)
n_monti <- length(levels(profile_data_monti$name))
profile_pal = rainbow(n, s=.6, v=.6)[sample(1:n,n, replace = FALSE)]
names(profile_pal) <- levels(profile_data_monti$name)

# Merge the palettes and replace the non-profile sequences with grey
all_pal <- c(seqs_pal, profile_pal)
all_pal['non-profile sequences'] <- "#808080" 

# Join profiles and sequence data together into single dataframe and add more metadata
all_data_monti <- rbind(seqs_long_monti, profile_data_monti) 
save(all_data_monti, file = "all_data_monti.RData")
```


## Loading Isopora Data
```{r Isopora}
# Convert to long format
seqs_long_iso <- seqs_iso %>%
  filter(!is.na(sample_name)) %>%
  select(sample_name, `A1`:`G3ai`) %>%
  pivot_longer(`A1`:`G3ai`) %>%
  filter(value > 0) %>% # Remove zero values
  left_join(., meta)

# Q. Are we working with the post-med seqs according to the metadata in seqs?
san_check_iso <- seqs_long_iso %>%
  group_by(sample_name) %>%
  summarise(total = sum(value)) #A. yes

# Create a list of samples to keep that didnt fail to sequence
keepers_ss <- san_check_iso %>%
  filter(total > 1500)

non_keep <- san_check_iso %>% 
  filter(total < 1500)

#No sequences are filtered out

# Filter out the failed samples
seqs_long_iso <- seqs_long_iso %>%
  filter(sample_name %in% keepers_ss$sample_name) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) %>% # Convert to relative abundance
  ungroup() %>%
  mutate(name = as.factor(name)) # Make sample names a factor

# Create a random palette for each sequence
n <- length(levels(seqs_long_iso$name))
seqs_pal = rainbow(n, s=.6, v=.9)[sample(1:n,n, replace = FALSE)]
names(seqs_pal) <- levels(seqs_long_iso$name)

# Read in the profile data
profiles_raw_iso <- read_tsv("profiles.abs.Isopora.txt", skip = 6) %>%
    select(sample_name = `...2`, `A1`:`F4q`) %>%
    filter(!is.na(sample_name)) %>%
  select(sample_name, `A1`:`F4q`)

#Convert to long format 
profiles_long_iso <- profiles_raw_iso %>%
  pivot_longer(`A1`:`F4q`) %>% # Convert it to long format
  mutate(name = paste0("p_", name)) %>% # Add a p_ to the beginning of each profile (Some profiles are single sequence profiles and clash with the Sequence names)
  filter(sample_name %in% seqs_long_iso$sample_name) %>% # Remove samples that dont appear in the Sequence dataframe
  group_by(sample_name) %>%
  mutate(value = as.numeric(value)) %>%
  filter(value > 0) %>% # Remove 0 abundance profiles
  mutate(sample_name = as.factor(sample_name),
         name = as.factor(name)) %>% 
  ungroup() %>%
  left_join(., meta) # Add in metadata

# What is the total number of profile-related sequences in each sample?
profiles_sum_iso <- profiles_long_iso %>%
  group_by(sample_name) %>%
  summarise(total = sum(value))

# How many sequences in each sample are not part of a profile?
residual_iso <- left_join(profiles_sum_iso, san_check_iso, by = "sample_name") %>%
  mutate(residual = total.y - total.x) %>%
  select(sample_name, value = residual) %>%
  mutate(name = "non-profile sequences") %>%
  left_join(., meta)

# Combine the profiles and non-profile sequences
profile_data_iso <- rbind(profiles_long_iso, residual_iso) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) # convert to relative abundance - in that sample 


# Join profiles and sequence data together into single dataframe and add more metadata
all_data_iso <- rbind(seqs_long_iso, profile_data_iso) 
save(all_data_iso, file = "all_data_iso.RData")
```

```{r}
# How many samples per species?
all_data_iso %>%
  distinct(sample_name, Reef) %>%
  group_by(Reef) %>% 
  summarise(total_samples = n())

isopora_study_total <- all_data_iso %>% 
   filter(!(str_detect(name, "p_")),
         name != "non-profile sequences") %>% 
  summarise(total_seqs = sum(value)) %>%
  pull(total_seqs)

#9382894 sequences in isopora dataset
```

## Load Acropora Data

```{r Acropora}
# Convert to long format
seqs_long_acro <- seqs_acro %>%
  filter(!is.na(sample_name)) %>%
  select(sample_name, `A1`:`G3ai`) %>%
  pivot_longer(`A1`:`G3ai`) %>%
  filter(value > 0) %>% # Remove zero values
  left_join(., meta)

# Q. Are we working with the post-med seqs according to the metadata in seqs?
san_check_acro <- seqs_long_acro %>%
  group_by(sample_name) %>%
  summarise(total = sum(value)) #A. yes

# Create a list of samples to keep that didnt fail to sequence
keepers_ss <- san_check_acro %>%
  filter(total > 1500)

non_keep <- san_check_acro %>% 
  filter(total < 1500)

#we filter out 2 samples with less than A142 and A191

# Filter out the failed samples
seqs_long_acro <- seqs_long_acro %>%
  filter(sample_name %in% keepers_ss$sample_name) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) %>% # Convert to relative abundance
  ungroup() %>%
  mutate(name = as.factor(name)) # Make sample names a factor

# Create a random palette for each sequence
n_acro <- length(levels(seqs_long_acro$name))
seqs_pal = rainbow(n, s=.6, v=.9)[sample(1:n,n, replace = FALSE)]
names(seqs_pal) <- levels(seqs_long_acro$name)

# Read in the profile data
profiles_raw_acro <- read_tsv("profiles.abs.acro.txt", skip = 6) %>%
    select(sample_name = `...2`, `A1-A1gr-A1gd-A1mm-A1bf`:`D1-D17i-D17s-D1r-D17r`) %>%
    filter(!is.na(sample_name)) %>%
  select(sample_name, `A1-A1gr-A1gd-A1mm-A1bf`:`D1-D17i-D17s-D1r-D17r`)

#Convert to long format 
profiles_long_acro <- profiles_raw_acro%>%
  pivot_longer(`A1-A1gr-A1gd-A1mm-A1bf`:`D1-D17i-D17s-D1r-D17r`) %>% # Convert it to long format
  mutate(name = paste0("p_", name)) %>% # Add a p_ to the beginning of each profile (Some profiles are single sequence profiles and clash with the Sequence names)
  filter(sample_name %in% seqs_long_acro$sample_name) %>% # Remove samples that dont appear in the Sequence dataframe
  group_by(sample_name) %>%
  mutate(value = as.numeric(value)) %>%
  filter(value > 0) %>% # Remove 0 abundance profiles
  mutate(sample_name = as.factor(sample_name),
         name = as.factor(name)) %>% 
  ungroup() %>%
  left_join(., meta) # Add in metadata

# What is the total number of profile-related sequences in each sample?
profiles_sum_acro <- profiles_long_acro %>%
  group_by(sample_name) %>%
  summarise(total = sum(value))

# How many sequences in each sample are not part of a profile?
residual_acro <- left_join(profiles_sum_acro, san_check_acro, by = "sample_name") %>%
  mutate(residual = total.y - total.x) %>%
  select(sample_name, value = residual) %>%
  mutate(name = "non-profile sequences") %>%
  left_join(., meta)

# Combine the profiles and non-profile sequences
profile_data_acro <- rbind(profiles_long_acro, residual_acro) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) # convert to relative abundance - in that sample 


# Join profiles and sequence data together into single dataframe and add more metadata
all_data_acro <- rbind(seqs_long_acro, profile_data_acro) 

save(all_data_acro, file = "all_data_acro.RData")
```

Palettes - not sure necessary
```{r}
# Create palette for profiles (this is a darker palette)
n_acro <- length(levels(profile_data_acro$name))
profile_pal = rainbow(n, s=.6, v=.6)[sample(1:n,n, replace = FALSE)]
names(profile_pal) <- levels(profile_data_acro$name)

# Merge the palettes and replace the non-profile sequences with grey
all_pal_acro <- c(seqs_pal, profile_pal)
all_pal['non-profile sequences'] <- "#808080" 
```



# 1 UPGMA Stats

#1.1 Isopora 

```{r}
seq_data_iso <- all_data_iso %>% 
  filter(!str_detect(name, "non")) %>% 
  filter(!str_detect(name, "p_"))
```

Importing fasta sequences
```{r}
fasta_iso_symbioant <- read_fasta_df("seqs.isopora.fasta") %>% 
   filter(label %in% seqs_long_iso$name) %>%   #only keeping DNA seqs that appear in seqs_long subset 
  deframe() %>%
  as_dna()
```

##1.1.1 Creating the tree
```{r}
#creating the tree
kdist_iso_symbioant <- fasta_iso_symbioant %>%
  dna_to_DNAbin() %>%
  kdistance(k = 7, residues = "DNA", method = "edgar") %>%
  as.matrix()
```

```{r}
#k_tree_iso_symbioant <- kdist_iso_symbioant %>% phangorn::upgma()

#k_tree_iso_symbioant

#save(k_tree_iso_symbioant, file = "kdist_iso_symbioant.RData")
load("~/AIMS@JCU/CoralSeaSymbioants/Coral-Sea-Cophylogeny-2025/kdist_iso_symbioant.RData")
```

```{r}
seqs_wide_iso_symbioant <- seq_data_iso %>%
  dplyr::select(sample_name, name, value) %>%
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name")

head(seqs_wide_iso_symbioant)
```

###1.1.2. GUniFrac and Kdist Matrix
```{r}
k_unidist_iso_symbioant <- GUniFrac(seqs_wide_iso_symbioant, k_tree_iso_symbioant)   #GUniFrac calculates all the distances 
k_unidist_iso_symbioant <- k_unidist_iso_symbioant$unifracs


 # GUniFrac with alpha 0.5 (i.e Generalised UniFrac Distance)
du_iso_symbioant <- k_unidist_iso_symbioant[, , "d_0.5"]   
dist_iso_symbioant <- as.dist(du_iso_symbioant, diag = FALSE)

# Cluster the samples
hclust_samps_iso_symbioant <- upgma(du_iso_symbioant)

# Make the sample tree
tree_iso_symbioant <- ggtree(hclust_samps_iso_symbioant, size = 0.2) +
  theme(aspect.ratio = 0.3) + layout_dendrogram()

# Get a sample order from ggtree
iso_sample_order <- tree_iso_symbioant$data %>% filter(isTip == "TRUE") %>%
  arrange(y) %>%
  pull(label)

# Start plotting the composition data
plot_df_iso_symbioant <- all_data_iso %>%
  mutate(sample_name = fct_relevel(sample_name, iso_sample_order))

theme_set(theme_bw())


# find the likely distinguishing seqs in here
test_df <- seq_data_iso %>%
   group_by(name) %>%
   summarise(mean = mean(value_rel), n = n()) %>%
   arrange(desc(n), desc(mean))

# colour them black to check
 test_pal <- all_pal
# test_pal['C21ab'] <- "#000000" 
```

## Fig X
```{r}
bar_uni_iso_symbioant <- 
ggplot(plot_df_iso_symbioant, aes(sample_name, value_rel)) +
geom_bar(stat = "identity", aes(fill = name, colour = name)) +
theme(aspect.ratio = 0.5, legend.position = "none", axis.text.y=element_blank(), axis.ticks.y = element_blank(),
      axis.text.x=element_blank(), axis.ticks.x = element_blank(),
      axis.title.x = element_blank(), axis.title.y = element_blank(),
      panel.border = element_blank(), panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), axis.ticks = element_blank()) +
scale_fill_manual(values = all_pal, breaks = levels(profile_data_iso$name)) +
scale_colour_manual(values = all_pal, breaks = levels(profile_data_iso$name)) +
geom_hline(yintercept = 1, size = 1) +
guides(fill=guide_legend(ncol=2))


#p_bar_uni is the sequences by colour. P_tree_tip is the tree coloured by reef. 

tree_iso_symbioant / bar_uni_iso_symbioant
```


```{r}
# Create reef strip
reef_strip_iso <- ggplot(plot_df_iso_symbioant, aes(x = sample_name, y = 1, fill = Reef)) +
  geom_tile() +
  theme_void() +
  theme(legend.position = "top") #+
 # scale_fill_brewer(palette = "Set2")  # or use your own palette

# Now combine the reef strip and your barplot
combined_plot_iso <- reef_strip_iso / bar_uni_iso_symbioant + plot_layout(heights = c(0.1, 1))

# Display it
combined_plot_iso
```


# 1.2 Montipora

```{r}
seq_data_monti <- all_data_monti %>% 
  filter(!str_detect(name, "non")) %>% 
  filter(!str_detect(name, "p_"))
```

```{r}
fasta_monti <- read_fasta_df("seqs.monti.fasta") %>% 
   filter(label %in% seqs_long_monti$name) %>%   #only keeping DNA seqs that appear in seqs_long subset 
  deframe() %>%
  as_dna()
```

```{r eval =FALSE}
#creating the tree
kdist_monti <- fasta_monti %>%
  dna_to_DNAbin() %>%
  kdistance(k = 7, residues = "DNA", method = "edgar") %>%
  as.matrix()
```

```{r eval=FALSE}
k_tree_monti <- kdist_monti %>% phangorn::upgma()

k_tree_monti
```

```{r}
seqs_wide_monti <- seq_data_monti %>%
  dplyr::select(sample_name, name, value) %>%
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name")

head(seqs_wide_monti)
```

```{r}
#k_unidist_monti <- GUniFrac(seqs_wide_monti, k_tree_monti)   #GUniFrac calculates all the distances 
#k_unidist_monti <- k_unidist_monti$unifracs

load("~/AIMS@JCU/CoralSeaSymbioants/Coral-Sea-Cophylogeny-2025/k_unidist_monti.RData")

 # GUniFrac with alpha 0.5 (i.e Generalised UniFrac Distance)
du_monti <- k_unidist_monti[, , "d_0.5"]   
dist_monti <- as.dist(du_monti, diag = FALSE)

dist_monti_symbioant <- dist_monti

# Cluster the samples
hclust_samps_monti <- upgma(du_monti)

# Make the sample tree
tree_monti <- ggtree(hclust_samps_monti, size = 0.2) +
  theme(aspect.ratio = 0.3) + layout_dendrogram()

# Get a sample order from ggtree
monti_sample_order <- tree_monti$data %>% filter(isTip == "TRUE") %>%
  arrange(y) %>%
  pull(label)

# Start plotting the composition data
plot_df_monti <- all_data_monti %>%
  mutate(sample_name = fct_relevel(sample_name, monti_sample_order))

theme_set(theme_bw())


# find the likely distinguishing seqs in here
test_df <- seq_data_monti %>%
   group_by(name) %>%
   summarise(mean = mean(value_rel), n = n()) %>%
   arrange(desc(n), desc(mean))

# colour them black to check
 test_pal <- all_pal
# test_pal['C21ab'] <- "#000000" 
```

## Fig 2B
```{r}
bar_uni_monti <- 
ggplot(plot_df_monti, aes(sample_name, value_rel)) +
geom_bar(stat = "identity", aes(fill = name, colour = name)) +
theme(aspect.ratio = 0.5, legend.position = "none", axis.text.y=element_blank(), axis.ticks.y = element_blank(),
      axis.text.x=element_blank(), axis.ticks.x = element_blank(),
      axis.title.x = element_blank(), axis.title.y = element_blank(),
      panel.border = element_blank(), panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), axis.ticks = element_blank()) +
scale_fill_manual(values = all_pal, breaks = levels(profile_data_monti$name)) +
scale_colour_manual(values = all_pal, breaks = levels(profile_data_monti$name)) +
geom_hline(yintercept = 1, size = 1) +
guides(fill=guide_legend(ncol=2))


#p_bar_uni is the sequences by colour. P_tree_tip is the tree coloured by reef. 

tree_monti / bar_uni_monti
```


```{r}
# Create reef strip
reef_strip_monti <- ggplot(plot_df_monti, aes(x = sample_name, y = 1, fill = Reef)) +
  geom_tile() +
  theme_void() +
  theme(legend.position = "top") #+
 # scale_fill_brewer(palette = "Set2")  # or use your own palette

# Now combine the reef strip and your barplot
combined_plot_monti <- reef_strip_monti / bar_uni_monti + plot_layout(heights = c(0.1, 1))

# Display it
combined_plot_monti
```


# 1.3 Acropora
```{r}
seq_data_acro <- all_data_acro %>% 
  filter(!str_detect(name, "non")) %>% 
  filter(!str_detect(name, "p_"))
```

Importing fasta sequences
```{r}
fasta_acro_symbioant <- read_fasta_df("seqs.acro.fasta") %>% 
   filter(label %in% seqs_long_acro$name) %>%   #only keeping DNA seqs that appear in seqs_long subset 
  deframe() %>%
  as_dna()
```

##1.3.1 Creating the tree
```{r}
#creating the tree
kdist_acro_symbioant <- fasta_acro_symbioant %>%
  dna_to_DNAbin() %>%
  kdistance(k = 7, residues = "DNA", method = "edgar") %>%
  as.matrix()
```

```{r}
k_tree_acro_symbioant <- kdist_acro_symbioant %>% phangorn::upgma()

k_tree_acro_symbioant

save(k_tree_acro_symbioant, file = "kdist_acro_symbioant.RData")
load("~/AIMS@JCU/CoralSeaSymbioants/Coral-Sea-Cophylogeny-2025/kdist_acro_symbioant.RData")
```

```{r}
seqs_wide_acro_symbioant <- seq_data_acro %>%
  dplyr::select(sample_name, name, value) %>%
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name")

head(seqs_wide_acro_symbioant)
```

###1.1.2. GUniFrac and Kdist Matrix
```{r}
k_unidist_acro_symbioant <- GUniFrac(seqs_wide_acro_symbioant, k_tree_acro_symbioant)   #GUniFrac calculates all the distances 
k_unidist_acro_symbioant <- k_unidist_acro_symbioant$unifracs


 # GUniFrac with alpha 0.5 (i.e Generalised UniFrac Distance)
du_acro_symbioant <- k_unidist_acro_symbioant[, , "d_0.5"]   
dist_acro_symbioant <- as.dist(du_acro_symbioant, diag = FALSE)

# Cluster the samples
hclust_samps_acro_symbioant <- upgma(du_acro_symbioant)

# Make the sample tree
tree_acro_symbioant <- ggtree(hclust_samps_acro_symbioant, size = 0.2) +
  theme(aspect.ratio = 0.3) + layout_dendrogram()

# Get a sample order from ggtree
acro_sample_order <- tree_acro_symbioant$data %>% filter(isTip == "TRUE") %>%
  arrange(y) %>%
  pull(label)

# Start plotting the composition data
plot_df_acro_symbioant <- all_data_acro %>%
  mutate(sample_name = fct_relevel(sample_name, acro_sample_order))

theme_set(theme_bw())


# find the likely distinguishing seqs in here
test_df <- seq_data_acro %>%
   group_by(name) %>%
   summarise(mean = mean(value_rel), n = n()) %>%
   arrange(desc(n), desc(mean))

# colour them black to check
 test_pal <- all_pal
# test_pal['C21ab'] <- "#000000" 
```

## Fig 2B
```{r}
bar_uni_acro_symbioant <- 
ggplot(plot_df_acro_symbioant, aes(sample_name, value_rel)) +
geom_bar(stat = "identity", aes(fill = name, colour = name)) +
theme(aspect.ratio = 0.5, legend.position = "none", axis.text.y=element_blank(), axis.ticks.y = element_blank(),
      axis.text.x=element_blank(), axis.ticks.x = element_blank(),
      axis.title.x = element_blank(), axis.title.y = element_blank(),
      panel.border = element_blank(), panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), axis.ticks = element_blank()) +
scale_fill_manual(values = all_pal, breaks = levels(profile_data_acro$name)) +
scale_colour_manual(values = all_pal, breaks = levels(profile_data_acro$name)) +
geom_hline(yintercept = 1, size = 1) +
guides(fill=guide_legend(ncol=2))


#p_bar_uni is the sequences by colour. P_tree_tip is the tree coloured by reef. 

tree_acro_symbioant / bar_uni_acro_symbioant
```


```{r}
# Create reef strip
reef_strip_acro <- ggplot(plot_df_acro_symbioant, aes(x = sample_name, y = 1, fill = Reef)) +
  geom_tile() +
  theme_void() +
  theme(legend.position = "top") #+
 # scale_fill_brewer(palette = "Set2")  # or use your own palette

# Now combine the reef strip and your barplot
combined_plot_acro <- reef_strip_acro / bar_uni_acro_symbioant + plot_layout(heights = c(0.1, 1))

# Display it
combined_plot_acro
```


# 2 PCoAs
**Here we are running a PCoA on UniFrac distances for the X communities associated with X different host groups (Isopora, Montipora spp., Acropora humulis) to look for patterns by reef in symbiont community structure** 

##4.1 PCoA by Reef

###4.1.1 Isopora Reef PCoA
```{r}
reef_order <- meta %>% rename(`GPS S` = "Lat") %>% 
  distinct(Reef, Lat) %>%
  group_by(Reef) %>%
  summarise(Lat = mean(Lat)) %>%
  arrange(Lat) %>%
  pull(Reef)
```

```{r}
pcoa_iso <- cmdscale(dist_iso_symbioant, eig = TRUE)    #this is doing 'cmds' or classic multidimensional scaling

#outlier_samples <- XX

ordiplot(pcoa_iso, display = 'sites', type = 'text')
barplot (pcoa_iso$eig, names = paste ('PCoA', 1:187), las = 5, ylab = 'eigenvalues') #invalid value specified for graphical parameter "las"

# Custom x and y labels
xlab = paste("Axis 1 (X%)")
ylab = paste("Axis 2 (X%)")

MDSxy.iso <- data.frame(pcoa_iso$points) %>% 
  rownames_to_column(var = "sample_name") %>% 
  left_join(., meta)# %>% 
 #  mutate(catBleaching = as.factor(catBleaching)) %>% 
 # filter(!(Vial %in% outlier_samples)) 

isoPCA <- MDSxy.iso %>%
  filter(Reef != "NA") %>% 
 # mutate(Reef = fct_relevel(Reef, reef_order)) %>%
  ggplot(aes(X1, X2, fill = Reef)) + 
  geom_point(alpha = 1, shape = 21, size = 3) + 
  scale_fill_viridis_d(option = "magma", direction = -1)+ 
#  scale_fill_manual(values = reef_pal) #+
 theme(legend.position = "none", aspect.ratio = 1, text = element_text(size = 15))

isoPCA
```

# 2.2 Montipora
```{r}
pcoa_monti <- cmdscale(dist_monti_symbioant, eig = TRUE)    #this is doing 'cmds' or classic multidimensional scaling

#outlier_samples <- XX

ordiplot(pcoa_monti, display = 'sites', type = 'text')
barplot (pcoa_monti$eig, names = paste ('PCoA', 1:187), las = 5, ylab = 'eigenvalues') #invalid value specified for graphical parameter "las"

# Custom x and y labels
xlab = paste("Axis 1 (X%)")
ylab = paste("Axis 2 (X%)")

MDSxy.monti <- data.frame(pcoa_monti$points) %>% 
  rownames_to_column(var = "sample_name") %>% 
  left_join(., meta)# %>% 
 #  mutate(catBleaching = as.factor(catBleaching)) %>% 
 # filter(!(Vial %in% outlier_samples)) 

montiPCA <- MDSxy.monti %>%
  filter(Reef != "NA") %>% 
 # mutate(Reef = fct_relevel(Reef, reef_order)) %>%
  ggplot(aes(X1, X2, fill = Reef)) + 
  geom_point(alpha = 1, shape = 21, size = 3) + 
  scale_fill_viridis_d(option = "magma", direction = -1)+ 
#  scale_fill_manual(values = reef_pal) #+
 theme(legend.position = "none", aspect.ratio = 1, text = element_text(size = 15))

montiPCA
```

##2.3 Acropora
```{r}
pcoa_acro <- cmdscale(dist_acro_symbioant, eig = TRUE)    #this is doing 'cmds' or classic multidimensional scaling

#outlier_samples <- XX

ordiplot(pcoa_acro, display = 'sites', type = 'text')
barplot (pcoa_acro$eig, names = paste ('PCoA', 1:187), las = 5, ylab = 'eigenvalues') #invalid value specified for graphical parameter "las"

# Custom x and y labels
xlab = paste("Axis 1 (X%)")
ylab = paste("Axis 2 (X%)")

MDSxy.acro <- data.frame(pcoa_acro$points) %>% 
  rownames_to_column(var = "sample_name") %>% 
  left_join(., meta)# %>% 
 #  mutate(catBleaching = as.factor(catBleaching)) %>% 
 # filter(!(Vial %in% outlier_samples)) 

acroPCA <- MDSxy.acro %>%
  filter(Reef != "NA") %>% 
 # mutate(Reef = fct_relevel(Reef, reef_order)) %>%
  ggplot(aes(X1, X2, fill = Reef)) + 
  geom_point(alpha = 1, shape = 21, size = 3) + 
  scale_fill_viridis_d(option = "magma", direction = -1)+ 
#  scale_fill_manual(values = reef_pal) #+
 theme(legend.position = "none", aspect.ratio = 1, text = element_text(size = 15))

acroPCA
```


# 3 Procrustes
implemented in symmetric mode, and calculated the residuals for each link. A P-value < 0.05 indicates a cophylogenetic signal between the coral host and Symbiodiniaceae, with both a P-value < 0.05 and an R2 close to 1 reflecting strong phylogenetic consistency between the two (Perez-Lamarque & Morlon, 2024). The
phylogenetic trees of Cladocopium spp. and Durusdinium spp.
were constructed using ITS2 profile Unifrac dissimilarity as a distance metric (Starko et al., 2023). Furthermore, the residual differences in the association between Robusta and Complexa with
Symbiodiniaceae were analyzed using a t-test
## 3.1 Isopora

```{r}



#code for defining specific colours per reef for procrustes plots later on
reef_pal2 <- c("#ac1917", "#e54a50", "#b75420", "#ea8553", "#c0982b", "#eec76b", "#768b45", "#a9be77", "#B2DFDB", "#4eaaa6", "#00798C")

reef_names <- c("Elizabeth", "Middleton", "Cato", "Wreck", "Kenn", "Mellish", "Marion","Frederick", "Saumarez", "Madgelaine", "NA")

names(reef_pal2) <- reef_names
```

```{r}
load("~/AIMS@JCU/CoralSeaSymbioants/Coral-Sea-Cophylogeny-2025/ind_coords_iso.RData")
iso_seqs_host <- ind_coords_iso %>% 
  mutate("sample_name" = VialID)

#here is the subset with the data that matches the host data
load("~/AIMS@JCU/CoralSeaSymbioants/Coral-Sea-Cophylogeny-2025/all_data_iso.RData")
seq_data_iso <- all_data_iso %>% 
  filter(!str_detect(name, "non")) %>% 
  filter(!str_detect(name, "p_"))

shared_seqs_iso <- inner_join(iso_seqs_host, seq_data_iso, by = "sample_name")

seq_data_iso %>% 
  distinct(sample_name) %>% 
  nrow()
 #should be 187 in the symbioant

shared_seqs_iso <- shared_seqs_iso %>% 
  select(sample_name)
```

### 3.1.1 Host tree

```{r}
load("~/AIMS@JCU/CoralSeaSymbioants/Coral-Sea-Cophylogeny-2025/iso_gen.RData") #load host data

library(adegenet) #install required package
library(poppr)


# Check your individual names in iso_gen
ind_names_host_iso <- indNames(iso_gen)

# Subset the genind object to retain only matching individuals
iso_gen_subset <- iso_gen[ind_names_host_iso %in% shared_seqs_iso$sample_name, ]

length(indNames(iso_gen))          # Before 189
length(indNames(iso_gen_subset))   # After 188

#Compute the pairwise distances between multivariate observations; used on raw allele frequencies.
host_shared_dist_iso <- dist(iso_gen_subset, method = "euclidean") #calculate euclidean distance 

# convert the distance matrix to a dist object
host_dist_matrix_iso <- as.dist(host_shared_dist_iso)

#Create a matrix with only common sample names for symbioant
seqs_wide_symbioant <- seq_data_iso %>%
  select(sample_name, name, value) %>%
  filter(sample_name %in% shared_seqs_iso$sample_name) %>% 
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name") #187 samples

#k_tree_iso_symbioant <- kdist_iso_symbioant %>% phangorn::upgma()

load("~/AIMS@JCU/CoralSeaSymbioants/Coral-Sea-Cophylogeny-2025/kdist_iso_symbioant.RData")

k_unidist_symbioant <- GUniFrac(seqs_wide_symbioant, k_tree_iso_symbioant)   #GUniFrac calculates all the distances 
k_unidist_symbioant <- k_unidist_symbioant$unifracs

 # GUniFrac with alpha 0.5 (i.e Generalised UniFrac Distance)
du_iso_symbioant <- k_unidist_symbioant[, , "d_0.5"]   
dist_iso_symbioant <- as.dist(du_iso_symbioant, diag = FALSE)
```

### 3.1.2 Symbioant Tree 

```{r}
#convert host (H) and symbiont (P) distance trees as data matrices
H.dist_iso <- host_dist_matrix_iso %>% as.matrix()
P.dist_iso <- dist_iso_symbioant %>% as.matrix() 
```

```{r}
#must have same number of dimensions 
dim(H.dist_iso)
dim(P.dist_iso) #its really odd that the symbioant has 186 when the code running above has 187 sample names

# Subset to only the samples that are in both datasets
intersect_samples_row_iso <- intersect(rownames(H.dist_iso), rownames(P.dist_iso))
intersect_samples_col_iso <- intersect(colnames(H.dist_iso), colnames(P.dist_iso)) # The host data set had 189, and the symbioant had 186
P.dist_intersect_iso <- P.dist_iso[intersect_samples_row_iso, intersect_samples_col_iso]
H.dist_intersect_iso <- H.dist_iso[intersect_samples_row_iso, intersect_samples_col_iso ]

# Subset to only the samples that are in both datasets
intersect_samples_iso <- intersect(rownames(H.dist_intersect_iso), rownames(P.dist_intersect_iso))
P.dist_iso <- P.dist_intersect_iso
H.dist_iso <- H.dist_intersect_iso

#recheck dimensions - all good 
dim(P.dist_iso)
dim(H.dist_iso)
```

### 3.1.3 Perform Paco analysis

```{r, include = FALSE}
# Perform Procrustes analysis. logical that symbionts depend on the host. so X = host and Y = symbiont. 

paco.iso <- procrustes(H.dist_iso, P.dist_iso, symmetric = FALSE)

paco.iso2 <- procrustes(H.dist_iso, P.dist_iso, symmetric = TRUE)
summary(paco.iso)

summary(paco.iso2)

#symmetric = FALSE: This specifies that the Procrustes rotation can be non-orthogonal (i.e. generalised), meaning that it can include scaling and shearing transformations in addition to rotation and reflection. This allows for more flexible alignment between the two dissimilarity matrices, but may result in a less interpretable or meaningful alignment depending on the nature of the data.


#statistics check for residuals 
#paco error chart 
plot(paco.iso, kind = 1, type = "text")

#show paco residuals. higher numbers mean these are the samples that have high dissimilarity between the symbiont and host trees
plot(paco.iso, kind = 2, type = "text")
```

Number of objects: 186    Number of dimensions: 186 

Procrustes sum of squares:  
 1.563793e+07 
Procrustes root mean squared error: 
 289.9567 
Quantiles of Procrustes errors:
     Min       1Q   Median       3Q      Max 
166.5647 262.5309 276.9388 319.7066 392.3467
*sum of squares here is ridiculous (over 1 million)*

##### Symmetric = TRUE
Call:
procrustes(X = H.dist_iso, Y = P.dist_iso, symmetric = TRUE) 

Number of objects: 186    Number of dimensions: 186 

Procrustes sum of squares:  
 0.8709314 
Procrustes root mean squared error: 
 0.06842826 
Quantiles of Procrustes errors:
       Min         1Q     Median         3Q        Max 
0.03930838 0.06195592 0.06535609 0.07544908 0.09259175 


### 3.1.4 Isopora procrustes plot

```{r}
#transfer PC coords into dataframe for plotting  
hp.df.iso <- data.frame(rda1=paco.iso2$Yrot[,1],
rda2=paco.iso2$Yrot[,2],xrda1=paco.iso2$X[,1],
xrda2=paco.iso2$X[,2]) %>% 
  tibble::rownames_to_column(var = "Vial") 

library(readxl)
#Vial is the unique genotype for each coral sample. 
CoralSea2024_Metadata <- read_excel("CoralSea2024_Metadata.xlsx")
meta <- CoralSea2024_Metadata %>% 
  rename("VialID" = "sample_name",
         "Depth (m)"= "Depth")

#filter metadata to just reef
meta.reef <- meta %>% 
  select(sample_name, Reef) %>% 
  rename(sample_name = "Vial")

#left join the metadata to get reef into the dataframe 
hp.df.iso2 <- hp.df.iso %>% left_join(meta.reef)

#create plot 
procrust.iso <- ggplot(hp.df.iso2) +
  geom_segment(aes(x=rda1,y=rda2,xend=xrda1,yend=xrda2), size = .2) +
  geom_point(aes(x=rda1, y=rda2, shape = "Host", color = Reef)) +
  geom_point(aes(x=xrda1, y=xrda2, shape = "Symbiont", color = Reef)) +
  scale_shape_manual(name = "Groups", 
                     values = c("Host" = 19, "Symbiont" = 17)) +
  scale_colour_manual(values = reef_pal2) +
    theme(legend.position = "none") +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank()) +
  theme(aspect.ratio = 1) 

save(procrust.iso, file = "procrust.iso2.RData")
```

## 3.2 Montipora
```{r}
load("~/AIMS@JCU/CoralSeaSymbioants/Coral-Sea-Cophylogeny-2025/ind_coords_monti.RData")
monti_seqs_host <- ind_coords_monti %>% 
  mutate("sample_name" = VialID)
load("~/AIMS@JCU/CoralSeaSymbioants/Coral-Sea-Cophylogeny-2025/all_data_monti.RData")
seq_data_monti <- all_data_monti %>% 
  filter(!str_detect(name, "non")) %>% 
  filter(!str_detect(name, "p_"))

#here is the subset with the data that matches the host data
shared_seqs_monti <- inner_join(monti_seqs_host, seq_data_monti, by = "sample_name")

seq_data_monti %>% 
  distinct(sample_name) %>% 
  nrow()
 #should be 187 in the symbioant

shared_seqs_monti <- shared_seqs_monti %>% 
  select(sample_name)
```

### 3.2.1 Host tree

```{r}
load("~/AIMS@JCU/CoralSeaSymbioants/Coral-Sea-Cophylogeny-2025/monti_gen.RData") #load host data


library(adegenet) #install required package
library(poppr)


# Check your individual names in monti_gen
ind_names_host_monti <- indNames(monti_gen)

# Subset the genind object to retain only matching individuals
monti_gen_subset <- monti_gen[ind_names_host_monti %in% shared_seqs_monti$sample_name, ]

length(indNames(monti_gen))          # Before 189
length(indNames(monti_gen_subset))   # After 188

#Compute the pairwise distances between multivariate observations; used on raw allele frequencies.
host_shared_dist_monti <- dist(monti_gen_subset, method = "euclidean") #calculate euclidean distance 

# convert the distance matrix to a dist object
host_dist_matrix_monti <- as.dist(host_shared_dist_monti)

#Create a matrix with only common sample names for symbioant
seqs_wide_symbioant <- seq_data_monti %>%
  select(sample_name, name, value) %>%
  filter(sample_name %in% shared_seqs_monti$sample_name) %>% 
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name") #187 samples

#k_tree_monti_symbioant <- kdist_monti_symbioant %>% phangorn::upgma()

load("~/AIMS@JCU/CoralSeaSymbioants/Coral-Sea-Cophylogeny-2025/kdist_monti_symbioant.RData")


 # GUniFrac with alpha 0.5 (i.e Generalised UniFrac Distance)
du_monti_symbioant <- kdist_monti_symbioant[, , "d_0.5"]   
dist_monti_symbioant <- as.dist(du_monti_symbioant, diag = FALSE)
```

### 3.2.2 Symbioant Tree 

```{r}
#convert host (H) and symbiont (P) distance trees as data matrices
H.dist_monti <- host_dist_matrix_monti %>% as.matrix()
P.dist_monti <- dist_monti_symbioant %>% as.matrix() 
```

```{r}
#must have same number of dimensions 
dim(H.dist_monti)
dim(P.dist_monti) #its really odd that the symbioant has 186 when the code running above has 187 sample names

# Subset to only the samples that are in both datasets
intersect_samples_row_monti <- intersect(rownames(H.dist_monti), rownames(P.dist_monti))
intersect_samples_col_monti <- intersect(colnames(H.dist_monti), colnames(P.dist_monti)) # The host data set had 189, and the symbioant had 186
P.dist_intersect_monti <- P.dist[intersect_samples_row_monti, intersect_samples_col_monti]
H.dist_intersect_monti <- H.dist[intersect_samples_row_monti, intersect_samples_col_monti ]

# Subset to only the samples that are in both datasets
intersect_samples_monti <- intersect(rownames(H.dist_intersect_monti), rownames(P.dist_intersect_monti))
P.dist_monti <- P.dist_intersect_monti
H.dist_monti <- H.dist_intersect_monti

#recheck dimensions - all good 
dim(P.dist_monti)
dim(H.dist_monti)
```

### 3.1.3 Perform Paco analysis

```{r, include = FALSE}
# Perform Procrustes analysis. logical that symbionts depend on the host. so X = host and Y = symbiont. 

paco.monti <- procrustes(H.dist_monti, P.dist_monti, symmetric = FALSE)
summary(paco.monti)

#symmetric = FALSE: This specifies that the Procrustes rotation can be non-orthogonal (i.e. generalised), meaning that it can include scaling and shearing transformations in addition to rotation and reflection. This allows for more flexible alignment between the two dissimilarity matrices, but may result in a less interpretable or meaningful alignment depending on the nature of the data.


#statistics check for residuals 
#paco error chart 
plot(paco.monti, kind = 1, type = "text")

#show paco residuals. higher numbers mean these are the samples that have high dissimilarity between the symbiont and host trees
plot(paco.monti, kind = 2, type = "text")
```



### 3.2.4 montipora procrustes plot

```{r}
#transfer PC coords into dataframe for plotting  
hp.df.monti <- data.frame(rda1=paco.monti$Yrot[,1],
rda2=paco.monti$Yrot[,2],xrda1=paco.monti$X[,1],
xrda2=paco.monti$X[,2]) %>% 
  tibble::rownames_to_column(var = "Vial") 


#filter metadata to just reef
meta.reef <- meta %>% 
  select(sample_name, Reef) %>% 
  rename(sample_name = "Vial")

#left join the metadata to get reef into the dataframe 
hp.df.monti2 <- hp.df.monti %>% left_join(meta.reef)

#create plot 
procrust.monti <- ggplot(hp.df.monti2) +
  geom_segment(aes(x=rda1,y=rda2,xend=xrda1,yend=xrda2), size = .2) +
  geom_point(aes(x=rda1, y=rda2, shape = "Host", color = Reef)) +
  geom_point(aes(x=xrda1, y=xrda2, shape = "Symbiont", color = Reef)) +
  scale_shape_manual(name = "Groups", 
                     values = c("Host" = 19, "Symbiont" = 17)) +
  scale_colour_manual(values = reef_pal2) +
    theme(legend.position = "none") +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank()) +
  theme(aspect.ratio = 1) 

save(procrust.monti, file = "procrust.monti.RData")
```
## 3.3 Acropora
```{r}
load("~/AIMS@JCU/CoralSeaSymbioants/Coral-Sea-Cophylogeny-2025/all_data_acro.RData")

#here is the subset with the data that matches the host data
shared_seqs_acro <- inner_join(acro_seqs_host, seq_data_acro, by = "sample_name")

seq_data_acro %>% 
  distinct(sample_name) %>% 
  nrow()
 #should be 187 in the symbioant

shared_seqs_acro <- shared_seqs_acro %>% 
  select(sample_name)
```

### 3.3.1 Host tree

```{r}
load("~/AIMS@JCU/CoralSeaSymbioants/Coral-Sea-Cophylogeny-2025/acro_gen.RData") #load host data
load("~/AIMS@JCU/CoralSeaSymbioants/Coral-Sea-Cophylogeny-2025/all_data_acro.RData") #load symbioant data
seq_data_acro <- all_data_acro %>% 
  filter(!str_detect(name, "non")) %>% 
  filter(!str_detect(name, "p_"))

library(adegenet) #install required package
library(poppr)


# Check your individual names in acro_gen
ind_names_host_acro <- indNames(acro_gen)

# Subset the genind object to retain only matching individuals
acro_gen_subset <- acro_gen[ind_names_host_acro %in% shared_seqs_acro$sample_name, ]

length(indNames(acro_gen))          # Before 189
length(indNames(acro_gen_subset))   # After 188

#Compute the pairwise distances between multivariate observations; used on raw allele frequencies.
host_shared_dist_acro <- dist(acro_gen_subset, method = "euclidean") #calculate euclidean distance 

# convert the distance matrix to a dist object
host_dist_matrix_acro <- as.dist(host_shared_dist_acro)

#Create a matrix with only common sample names for symbioant
seqs_wide_symbioant <- seq_data_acro %>%
  select(sample_name, name, value) %>%
  filter(sample_name %in% shared_seqs_acro$sample_name) %>% 
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name") #187 samples

#k_tree_acro_symbioant <- kdist_acro_symbioant %>% phangorn::upgma()

load("~/AIMS@JCU/CoralSeaSymbioants/Coral-Sea-Cophylogeny-2025/kdist_acro_symbioant.RData")

k_unidist_symbioant <- GUniFrac(seqs_wide_symbioant, k_tree_acro_symbioant)   #GUniFrac calculates all the distances 
k_unidist_symbioant <- k_unidist_symbioant$unifracs


 # GUniFrac with alpha 0.5 (i.e Generalised UniFrac Distance)
du_acro_symbioant <- k_unidist_symbioant[, , "d_0.5"]   
dist_acro_symbioant <- as.dist(du_acro_symbioant, diag = FALSE)
```

### 3.3.2 Symbioant Tree 

```{r}
#convert host (H) and symbiont (P) distance trees as data matrices
H.dist_acro <- host_dist_matrix_acro %>% as.matrix()
P.dist_acro <- dist_acro_symbioant %>% as.matrix() 
```

```{r}
#must have same number of dimensions 
dim(H.dist_acro)
dim(P.dist_acro) #its really odd that the symbioant has 186 when the code running above has 187 sample names

# Subset to only the samples that are in both datasets
intersect_samples_row_acro <- intersect(rownames(H.dist_acro), rownames(P.dist_acro))
intersect_samples_col_acro <- intersect(colnames(H.dist_acro), colnames(P.dist_acro)) # The host data set had 189, and the symbioant had 186
P.dist_intersect_acro <- P.dist[intersect_samples_row_acro, intersect_samples_col_acro]
H.dist_intersect_acro <- H.dist[intersect_samples_row_acro, intersect_samples_col_acro ]

# Subset to only the samples that are in both datasets
intersect_samples_acro <- intersect(rownames(H.dist_intersect_acro), rownames(P.dist_intersect_acro))
P.dist_acro <- P.dist_intersect_acro
H.dist_acro <- H.dist_intersect_acro

#recheck dimensions - all good 
dim(P.dist_acro)
dim(H.dist_acro)
```

### 3.1.3 Perform Paco analysis

```{r, include = FALSE}
# Perform Procrustes analysis. logical that symbionts depend on the host. so X = host and Y = symbiont. 

paco.acro <- procrustes(H.dist_acro, P.dist_acro, symmetric = FALSE)
summary(paco.acro)

#symmetric = FALSE: This specifies that the Procrustes rotation can be non-orthogonal (i.e. generalised), meaning that it can include scaling and shearing transformations in addition to rotation and reflection. This allows for more flexible alignment between the two dissimilarity matrices, but may result in a less interpretable or meaningful alignment depending on the nature of the data.


#statistics check for residuals 
#paco error chart 
plot(paco.acro, kind = 1, type = "text")

#show paco residuals. higher numbers mean these are the samples that have high dissimilarity between the symbiont and host trees
plot(paco.acro, kind = 2, type = "text")
```



### 3.1.4 acropora procrustes plot

```{r}
#transfer PC coords into dataframe for plotting  
hp.df.acro <- data.frame(rda1=paco.acro$Yrot[,1],
rda2=paco.acro$Yrot[,2],xrda1=paco.acro$X[,1],
xrda2=paco.acro$X[,2]) %>% 
  tibble::rownames_to_column(var = "Vial") 


#filter metadata to just reef
meta.reef <- meta %>% 
  select(sample_name, Reef) %>% 
  rename(sample_name = "Vial")

#left join the metadata to get reef into the dataframe 
hp.df.acro2 <- hp.df.acro %>% left_join(meta.reef)

#create plot 
procrust.acro <- ggplot(hp.df.acro2) +
  geom_segment(aes(x=rda1,y=rda2,xend=xrda1,yend=xrda2), size = .2) +
  geom_point(aes(x=rda1, y=rda2, shape = "Host", color = Reef)) +
  geom_point(aes(x=xrda1, y=xrda2, shape = "Symbiont", color = Reef)) +
  scale_shape_manual(name = "Groups", 
                     values = c("Host" = 19, "Symbiont" = 17)) +
  scale_colour_manual(values = reef_pal2) +
    theme(legend.position = "none") +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank()) +
  theme(aspect.ratio = 1) 

save(procrust.acro, file = "procrust.acro.RData")
```