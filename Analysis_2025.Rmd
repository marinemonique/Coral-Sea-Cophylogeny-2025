---
title: "Analysis_2025"
author: "M. White based on M. Marzonie"
date: "25/04/2025"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load Data

### Load Libraries

```{r, warning = FALSE, echo = FALSE, message=FALSE}
library(ggsci)
library(tidyverse)
library(reshape2)
library(sangerseqR)
library(DECIPHER)
library(Biostrings)
library(phangorn)
library(ape)
library(ggplot2)
library(ggtree)
library(patchwork)
library(bioseq)
library(kmer)
library(GUniFrac)
library(seqinr)
library(vegan)
library(corrplot)
library(ggrepel)

library(ggmsa)
library(dendextend)
library(usedist)
```



### Load Symbiont Data
```{r, show_col_types = FALSE}
seqs_monti <- read_tsv("seqs.abs.monti.txt") %>% 
    filter(!(is.na(sample_name))) %>%
  dplyr::select(sample_name, `A1`:`G3ai`) %>% 
  mutate(sample_name = as.factor(sample_name)) %>% 
  filter(!grepl("-20", sample_name) & !grepl("b", sample_name))


seqs_iso <- read_tsv("seqs.abs.isopora.txt") %>% 
    filter(!(is.na(sample_name))) %>%
  dplyr::select(sample_name, `A1`:`G3ai`) %>% 
  mutate(sample_name = as.factor(sample_name)) %>% 
  filter(!grepl("-20", sample_name) & !grepl("b", sample_name))


seqs_acro <- read_tsv("seqs.abs.acro.txt") %>% 
    filter(!(is.na(sample_name))) %>%
  dplyr::select(sample_name, `A1`:`G3ai`) %>% 
  mutate(sample_name = as.factor(sample_name)) %>% 
  filter(!grepl("-20", sample_name) & !grepl("b", sample_name))

```


### Load Metadata

```{r}
library(readxl)
#Vial is the unique genotype for each coral sample. 
CoralSea2024_Metadata <- read_excel("CoralSea2024_Metadata.xlsx")

meta <- CoralSea2024_Metadata %>% 
  rename("VialID" = "sample_name",
         "Depth (m)"= "Depth")
```


### Load Custom Functions
```{r}
read_fasta_df <- function (file = "") {
  fasta <- readLines(file)
  ind <- grep(">", fasta)
  s <- data.frame(ind = ind, from = ind + 1, to = c((ind - 
    1)[-1], length(fasta)))
  seqs <- rep(NA, length(ind))
  for (i in 1:length(ind)) {
    seqs[i] <- paste(fasta[s$from[i]:s$to[i]], collapse = "")
  }
  tib <- tibble(label = gsub(">", "", fasta[ind]), sequence = seqs)
  return(tib)
}

write_fasta_df <- function (data, filename) 
{
    fastaLines = c()
    for (rowNum in 1:nrow(data)) {
        fastaLines = c(fastaLines, as.character(paste(">", 
            data[rowNum, "label"], sep = "")))
        fastaLines = c(fastaLines, as.character(data[rowNum, 
            "sequence"]))
    }
    fileConn <- file(filename)
    writeLines(fastaLines, fileConn)
    close(fileConn)
}

dna_to_DNAbin <- function (dna){
  DNAbin <- as_DNAbin(dna)
  names(DNAbin) <- names(dna)
  return(DNAbin)
}
dna_to_DNAStringset <- function(x) 
{
    bioseq:::check_dna(x)
    DNAstr <- DNAStringSet(paste(x))
    names(DNAstr) <- names(x)
    return(DNAstr)
}

DNAStringSet_to_dna <- function(x){
    x_dna <- as_dna(paste(x))
    names(x_dna) <- names(x)
    res <- tibble(label = names(x), sequence = x_dna)
    return(res)
}

# Convert DNAstringset to DNAbin
DNAStringSet_to_DNAbin <- function(DNAStringSet){
  DNAbin <- as.DNAbin(DNAStringSet)
  return(DNAbin)
}

# https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-018-2315-y
palette <- c("A" = "#46ff2d", 
             "G" = "#ffae01", 
             "C" = "#f24641", 
             "T" = "#4294fa", 
             "K" = "#8b4816",
             "M" = "#83831f",
             "R" = "#ffff81",
             "S" = "#ff9d80",
             "Y" = "#e381f2",
             "W" = "#80fff2",
             "V" = "#fde4b8",
             "B" = "#f9c1bf",
             "H" = "#c0d9f9",
             "D" = "#c7ffba",
             "U" = "#8989fb",
             "N" = "black", 
             "-" = "white",
             "+" = "White")


pal_df <- data.frame(names = names(palette), col = palette)
```



### Combining sequence/metadata 

## Loading Montipora Data

```{r}
# Convert to long format
seqs_long_monti <- seqs_monti %>%
  filter(!is.na(sample_name)) %>%
  select(sample_name, `A1`:`G3ai`) %>%
  pivot_longer(`A1`:`G3ai`) %>%
  filter(value > 0) %>% # Remove zero values
  left_join(., meta)

# Q. Are we working with the post-med seqs according to the metadata in seqs?
san_check_monti <- seqs_long_monti %>%
  group_by(sample_name) %>%
  summarise(total = sum(value)) #A. yes

# Create a list of samples to keep that didnt fail to sequence
keepers_ss <- san_check_monti %>%
  filter(total > 1500)

non_keep <- san_check_monti %>% 
  filter(total < 1500)

#we filter out 0 samples

# Filter out the failed samples (Not required for Montipora)
seqs_long_monti <- seqs_long_monti %>%
  filter(sample_name %in% keepers_ss$sample_name) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) %>% # Convert to relative abundance
  ungroup() %>%
  mutate(name = as.factor(name)) # Make sample names a factor

# Read in the profile data
profiles_raw_monti <- read_tsv("profiles.abs.monti.txt", skip = 6) %>%
    select(sample_name = `...2`, `A1-A1qd-A1qe`:`G3fd`) %>%
    filter(!is.na(sample_name)) %>%
  select(sample_name, `A1-A1qd-A1qe`:`G3fd`)

#Convert to long format 
profiles_long_monti <- profiles_raw_monti %>%
  pivot_longer(`A1-A1qd-A1qe`:`G3fd`) %>% # Convert it to long format
  mutate(name = paste0("p_", name)) %>% # Add a p_ to the beginning of each profile (Some profiles are single sequence profiles and clash with the Sequence names)
  filter(sample_name %in% seqs_long_monti$sample_name) %>% # Remove samples that dont appear in the Sequence dataframe
  group_by(sample_name) %>%
  mutate(value = as.numeric(value)) %>%
  filter(value > 0) %>% # Remove 0 abundance profiles
  mutate(sample_name = as.factor(sample_name),
         name = as.factor(name)) %>% 
  ungroup() %>%
  left_join(., meta) # Add in metadata

# What is the total number of profile-related sequences in each sample?
profiles_sum_monti <- profiles_long_monti %>%
  group_by(sample_name) %>%
  summarise(total = sum(value))

# How many sequences in each sample are not part of a profile?
residual_monti <- left_join(profiles_sum_monti, san_check_monti, by = "sample_name") %>%
  mutate(residual = total.y - total.x) %>%
  select(sample_name, value = residual) %>%
  mutate(name = "non-profile sequences") %>%
  left_join(., meta)

# Combine the profiles and non-profile sequences
profile_data_monti <- rbind(profiles_long_monti, residual_monti) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) # convert to relative abundance - in that sample 

# Join profiles and sequence data together into single dataframe and add more metadata
all_data_monti <- rbind(seqs_long_monti, profile_data_monti) 

save(all_data_monti, file = "all_data_monti.RData")

```


## Loading Isopora Data
```{r Isopora}
# Convert to long format
seqs_long_iso <- seqs_iso %>%
  filter(!is.na(sample_name)) %>%
  select(sample_name, `A1`:`G3ai`) %>%
  pivot_longer(`A1`:`G3ai`) %>%
  filter(value > 0) %>% # Remove zero values
  left_join(., meta)

# Q. Are we working with the post-med seqs according to the metadata in seqs?
san_check_iso <- seqs_long_iso %>%
  group_by(sample_name) %>%
  summarise(total = sum(value)) #A. yes

# Create a list of samples to keep that didnt fail to sequence
keepers_ss <- san_check_iso %>%
  filter(total > 1500)

non_keep <- san_check_iso %>% 
  filter(total < 1500)

#No sequences are filtered out

# Filter out the failed samples
seqs_long_iso <- seqs_long_iso %>%
  filter(sample_name %in% keepers_ss$sample_name) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) %>% # Convert to relative abundance
  ungroup() %>%
  mutate(name = as.factor(name)) # Make sample names a factor


# Read in the profile data
profiles_raw_iso <- read_tsv("profiles.abs.Isopora.txt", skip = 6) %>%
    select(sample_name = `...2`, `A1`:`F4q`) %>%
    filter(!is.na(sample_name)) %>%
  select(sample_name, `A1`:`F4q`)

#Convert to long format 
profiles_long_iso <- profiles_raw_iso %>%
  pivot_longer(`A1`:`F4q`) %>% # Convert it to long format
  mutate(name = paste0("p_", name)) %>% # Add a p_ to the beginning of each profile (Some profiles are single sequence profiles and clash with the Sequence names)
  filter(sample_name %in% seqs_long_iso$sample_name) %>% # Remove samples that dont appear in the Sequence dataframe
  group_by(sample_name) %>%
  mutate(value = as.numeric(value)) %>%
  filter(value > 0) %>% # Remove 0 abundance profiles
  mutate(sample_name = as.factor(sample_name),
         name = as.factor(name)) %>% 
  ungroup() %>%
  left_join(., meta) # Add in metadata

# What is the total number of profile-related sequences in each sample?
profiles_sum_iso <- profiles_long_iso %>%
  group_by(sample_name) %>%
  summarise(total = sum(value))

# How many sequences in each sample are not part of a profile?
residual_iso <- left_join(profiles_sum_iso, san_check_iso, by = "sample_name") %>%
  mutate(residual = total.y - total.x) %>%
  select(sample_name, value = residual) %>%
  mutate(name = "non-profile sequences") %>%
  left_join(., meta)

# Combine the profiles and non-profile sequences
profile_data_iso <- rbind(profiles_long_iso, residual_iso) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) # convert to relative abundance - in that sample 

# Join profiles and sequence data together into single dataframe and add more metadata
all_data_iso <- rbind(seqs_long_iso, profile_data_iso) 

save(all_data_iso, file = "all_data_iso.RData")

```

```{r}
# How many samples per species?
all_data_iso %>%
  distinct(sample_name, Reef) %>%
  group_by(Reef) %>% 
  summarise(total_samples = n())

isopora_study_total <- all_data_iso %>% 
   filter(!(str_detect(name, "p_")),
         name != "non-profile sequences") %>% 
  summarise(total_seqs = sum(value)) %>%
  pull(total_seqs)

#9382894 sequences in isopora dataset
```

## Load Acropora Data

```{r Acropora}
# Convert to long format
seqs_long_acro <- seqs_acro %>%
  filter(!is.na(sample_name)) %>%
  select(sample_name, `A1`:`G3ai`) %>%
  pivot_longer(`A1`:`G3ai`) %>%
  filter(value > 0) %>% # Remove zero values
  left_join(., meta)

# Q. Are we working with the post-med seqs according to the metadata in seqs?
san_check_acro <- seqs_long_acro %>%
  group_by(sample_name) %>%
  summarise(total = sum(value)) #A. yes

# Create a list of samples to keep that didnt fail to sequence
keepers_ss <- san_check_acro %>%
  filter(total > 1500)

non_keep <- san_check_acro %>% 
  filter(total < 1500)

#we filter out 2 samples with less than A142 and A191

# Filter out the failed samples
seqs_long_acro <- seqs_long_acro %>%
  filter(sample_name %in% keepers_ss$sample_name) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) %>% # Convert to relative abundance
  ungroup() %>%
  mutate(name = as.factor(name)) # Make sample names a factor


# Read in the profile data
profiles_raw_acro <- read_tsv("profiles.abs.acro.txt", skip = 6) %>%
    select(sample_name = `...2`, `A1-A1gr-A1gd-A1mm-A1bf`:`D1-D17i-D17s-D1r-D17r`) %>%
    filter(!is.na(sample_name)) %>%
  select(sample_name, `A1-A1gr-A1gd-A1mm-A1bf`:`D1-D17i-D17s-D1r-D17r`)

#Convert to long format 
profiles_long_acro <- profiles_raw_acro%>%
  pivot_longer(`A1-A1gr-A1gd-A1mm-A1bf`:`D1-D17i-D17s-D1r-D17r`) %>% # Convert it to long format
  mutate(name = paste0("p_", name)) %>% # Add a p_ to the beginning of each profile (Some profiles are single sequence profiles and clash with the Sequence names)
  filter(sample_name %in% seqs_long_acro$sample_name) %>% # Remove samples that dont appear in the Sequence dataframe
  group_by(sample_name) %>%
  mutate(value = as.numeric(value)) %>%
  filter(value > 0) %>% # Remove 0 abundance profiles
  mutate(sample_name = as.factor(sample_name),
         name = as.factor(name)) %>% 
  ungroup() %>%
  left_join(., meta) # Add in metadata

# What is the total number of profile-related sequences in each sample?
profiles_sum_acro <- profiles_long_acro %>%
  group_by(sample_name) %>%
  summarise(total = sum(value))

# How many sequences in each sample are not part of a profile?
residual_acro <- left_join(profiles_sum_acro, san_check_acro, by = "sample_name") %>%
  mutate(residual = total.y - total.x) %>%
  select(sample_name, value = residual) %>%
  mutate(name = "non-profile sequences") %>%
  left_join(., meta)

# Combine the profiles and non-profile sequences
profile_data_acro <- rbind(profiles_long_acro, residual_acro) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) # convert to relative abundance - in that sample 


# Join profiles and sequence data together into single dataframe and add more metadata
all_data_acro <- rbind(seqs_long_acro, profile_data_acro) 

save(all_data_acro, file = "all_data_acro.RData")
```




# PCoAs
**Here we are running a PCoA on UniFrac distances for the X communities associated with X different host groups (Isopora, Montipora spp., Acropora humulis) to look for patterns by reef in symbiont community structure** 



##Create distance matrix for symbionts
### 2.1.1 Isopora Distance Matrix

```{r eval=FALSE}
fasta_iso_symbiont <- read_fasta_df("seqs.isopora.fasta") %>% 
  filter(label %in% seqs_long_iso$name) %>%   #only keeping DNA seqs that appear in seqs_long subset 
  deframe() %>%
  as_dna()

#creating the tree
kdist_iso_symbiont <- fasta_iso_symbiont %>%
  dna_to_DNAbin() %>%
  kdistance(k = 7, residues = "DNA", method = "edgar") %>%
  as.matrix()

k_tree_iso_symbiont <- kdist_iso_symbiont %>% phangorn::upgma()

k_tree_iso_symbiont

save(k_tree_iso_symbiont, file = "kdist_iso_symbiont.RData")
```


```{r}
seq_data_iso <- all_data_iso %>% 
  filter(!str_detect(name, "non")) %>% 
  filter(!str_detect(name, "p_"))

seqs_wide_iso_symbiont <- seq_data_iso %>%
  dplyr::select(sample_name, name, value) %>%
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name")

#head(seqs_wide_iso_symbiont)
```


```{r}
load("~/AIMS@JCU/CoralSeaSymbionts/Coral-Sea-Cophylogeny-2025/kdist_iso_symbiont.RData")
k_unidist_iso_symbiont <- GUniFrac(seqs_wide_iso_symbiont, k_tree_iso_symbiont)   #GUniFrac calculates all the distances 
k_unidist_iso_symbiont <- k_unidist_iso_symbiont$unifracs


# GUniFrac with alpha 0.5 (i.e Generalised UniFrac Distance)
du_iso_symbiont <- k_unidist_iso_symbiont[, , "d_0.5"]   
dist_iso_symbiont <- as.dist(du_iso_symbiont, diag = FALSE)
```
### 2.1.2 Montipora Distance Matrix

```{r}
seq_data_monti <- all_data_monti %>% 
  filter(!str_detect(name, "non")) %>% 
  filter(!str_detect(name, "p_"))

fasta_monti <- read_fasta_df("seqs.monti.fasta") %>% 
  filter(label %in% seqs_long_monti$name) %>%   #only keeping DNA seqs that appear in seqs_long subset 
  deframe() %>%
  as_dna()
```


```{r eval =FALSE}
#creating the tree
kdist_monti <- fasta_monti %>%
  dna_to_DNAbin() %>%
  kdistance(k = 7, residues = "DNA", method = "edgar") %>%
  as.matrix()

k_tree_monti <- kdist_monti %>% phangorn::upgma()

k_tree_monti

```

```{r}
seqs_wide_monti <- seq_data_monti %>%
  dplyr::select(sample_name, name, value) %>%
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name")

#head(seqs_wide_monti)
```

```{r}
#k_unidist_monti <- GUniFrac(seqs_wide_monti, k_tree_monti)   #GUniFrac calculates all the distances 
#k_unidist_monti <- k_unidist_monti$unifracs

load("~/AIMS@JCU/CoralSeaSymbionts/Coral-Sea-Cophylogeny-2025/kdist_monti_symbiont.RData")

# GUniFrac with alpha 0.5 (i.e Generalised UniFrac Distance)
du_monti <- k_unidist_monti[, , "d_0.5"]   
dist_monti <- as.dist(du_monti, diag = FALSE)

dist_monti_symbiont <- dist_monti

```



### 2.1.3 Acropora Symbiont Distance Matrix

```{r}
seq_data_acro <- all_data_acro %>% 
  filter(!str_detect(name, "non")) %>% 
  filter(!str_detect(name, "p_"))
```

Importing fasta sequences
```{r eval = FALSE}
fasta_acro_symbiont <- read_fasta_df("seqs.acro.fasta") %>% 
  filter(label %in% seqs_long_acro$name) %>%   #only keeping DNA seqs that appear in seqs_long subset 
  deframe() %>%
  as_dna()

#creating the tree
kdist_acro_symbiont <- fasta_acro_symbiont %>%
  dna_to_DNAbin() %>%
  kdistance(k = 7, residues = "DNA", method = "edgar") %>%
  as.matrix()

k_tree_acro_symbiont <- kdist_acro_symbiont %>% phangorn::upgma()

k_tree_acro_symbiont

save(k_tree_acro_symbiont, file = "kdist_acro_symbiont.RData")

```

```{r}
load("~/AIMS@JCU/CoralSeaSymbionts/Coral-Sea-Cophylogeny-2025/kdist_acro_symbiont.RData")

seqs_wide_acro_symbiont <- seq_data_acro %>%
  dplyr::select(sample_name, name, value) %>%
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name")

#head(seqs_wide_acro_symbiont)
```

GUniFrac and Kdist Matrix
```{r}
k_unidist_acro_symbiont <- GUniFrac(seqs_wide_acro_symbiont, k_tree_acro_symbiont)   #GUniFrac calculates all the distances 
k_unidist_acro_symbiont <- k_unidist_acro_symbiont$unifracs


# GUniFrac with alpha 0.5 (i.e Generalised UniFrac Distance)
du_acro_symbiont <- k_unidist_acro_symbiont[, , "d_0.5"]   
dist_acro_symbiont <- as.dist(du_acro_symbiont, diag = FALSE)

# Cluster the samples
hclust_samps_acro_symbiont <- upgma(du_acro_symbiont)
```


##2.2 PCoA by Reef

###2.2.1 Isopora Reef PCoA
```{r}
reef_order <- meta %>% rename(`GPS S` = "Lat") %>% 
  distinct(Reef, Lat) %>%
  group_by(Reef) %>%
  summarise(Lat = mean(Lat)) %>%
  arrange(Lat) %>%
  pull(Reef)
```

```{r}
pcoa_iso <- cmdscale(dist_iso_symbiont, eig = TRUE)    #this is doing 'cmds' or classic multidimensional scaling

#outlier_samples <- XX

ordiplot(pcoa_iso, display = 'sites', type = 'text')
barplot (pcoa_iso$eig, names = paste ('PCoA', 1:187), 
         #las = 5, 
         ylab = 'eigenvalues') #invalid value specified for graphical parameter "las"

# Custom x and y labels
xlab = paste("Axis 1 (X%)")
ylab = paste("Axis 2 (X%)")

MDSxy.iso <- data.frame(pcoa_iso$points) %>% 
  rownames_to_column(var = "sample_name") %>% 
  left_join(., meta)# %>% 
 #  mutate(catBleaching = as.factor(catBleaching)) %>% 
 # filter(!(Vial %in% outlier_samples)) 

isoPCA <- MDSxy.iso %>%
  filter(Reef != "NA") %>% 
 # mutate(Reef = fct_relevel(Reef, reef_order)) %>%
  ggplot(aes(X1, X2, fill = Reef)) + 
  geom_point(alpha = 1, shape = 21, size = 3) + 
  scale_fill_viridis_d(option = "magma", direction = -1)+ 
#  scale_fill_manual(values = reef_pal) #+
 theme(legend.position = "none", aspect.ratio = 1, text = element_text(size = 15))

isoPCA
```

### 2.2.2 Montipora
```{r}
pcoa_monti <- cmdscale(dist_monti_symbiont, eig = TRUE)    #this is doing 'cmds' or classic multidimensional scaling

#outlier_samples <- XX

ordiplot(pcoa_monti, display = 'sites', type = 'text')
barplot (pcoa_monti$eig, names = paste ('PCoA', 1:187), 
         #las = 5, 
         ylab = 'eigenvalues') #invalid value specified for graphical parameter "las"

# Custom x and y labels
xlab = paste("Axis 1 (X%)")
ylab = paste("Axis 2 (X%)")

MDSxy.monti <- data.frame(pcoa_monti$points) %>% 
  rownames_to_column(var = "sample_name") %>% 
  left_join(., meta)# %>% 
 #  mutate(catBleaching = as.factor(catBleaching)) %>% 
 # filter(!(Vial %in% outlier_samples)) 

montiPCA <- MDSxy.monti %>%
  filter(Reef != "NA") %>% 
 # mutate(Reef = fct_relevel(Reef, reef_order)) %>%
  ggplot(aes(X1, X2, fill = Reef)) + 
  geom_point(alpha = 1, shape = 21, size = 3) + 
  scale_fill_viridis_d(option = "magma", direction = -1)+ 
#  scale_fill_manual(values = reef_pal) #+
 theme(legend.position = "none", aspect.ratio = 1, text = element_text(size = 15))

montiPCA
```

###2.2.3 Acropora
```{r}
pcoa_acro <- cmdscale(dist_acro_symbiont, eig = TRUE)    #this is doing 'cmds' or classic multidimensional scaling

#outlier_samples <- XX

ordiplot(pcoa_acro, display = 'sites', type = 'text')
barplot (pcoa_acro$eig, names = paste ('PCoA', 1:354), 
         #las = 5, 
         ylab = 'eigenvalues') #invalid value specified for graphical parameter "las"

# Custom x and y labels
xlab = paste("Axis 1 (X%)")
ylab = paste("Axis 2 (X%)")

MDSxy.acro <- data.frame(pcoa_acro$points) %>% 
  rownames_to_column(var = "sample_name") %>% 
  left_join(., meta)# %>% 
 #  mutate(catBleaching = as.factor(catBleaching)) %>% 
 # filter(!(Vial %in% outlier_samples)) 

acroPCA <- MDSxy.acro %>%
  filter(Reef != "NA") %>% 
 # mutate(Reef = fct_relevel(Reef, reef_order)) %>%
  ggplot(aes(X1, X2, fill = Reef)) + 
  geom_point(alpha = 1, shape = 21, size = 3) + 
  scale_fill_viridis_d(option = "magma", direction = -1)+ 
#  scale_fill_manual(values = reef_pal) #+
 theme(legend.position = "none", aspect.ratio = 1, text = element_text(size = 15))

acroPCA
```


# 3 Procrustes
implemented in symmetric mode, and calculated the residuals for each link. A P-value < 0.05 indicates a cophylogenetic signal between the coral host and Symbiodiniaceae, with both a P-value < 0.05 and an R2 close to 1 reflecting strong phylogenetic consistency between the two (Perez-Lamarque & Morlon, 2024). The
phylogenetic trees of Cladocopium spp. and Durusdinium spp.
were constructed using ITS2 profile Unifrac dissimilarity as a distance metric (Starko et al., 2023). Furthermore, the residual differences in the association between Robusta and Complexa with
Symbiodiniaceae were analyzed using a t-test

## 3.1 Isopora

```{r}
#code for defining specific colours per reef for procrustes plots later on
reef_pal2 <- c("#ac1917", "#e54a50", "#b75420", "#ea8553", "#c0982b", "#eec76b", "#768b45", "#a9be77", "#B2DFDB", "#4eaaa6", "#00798C")

reef_names <- c("Elizabeth", "Middleton", "Cato", "Wreck", "Kenn", "Mellish", "Marion","Frederick", "Saumarez", "Madgelaine", "NA")

names(reef_pal2) <- reef_names
```

```{r}
load("~/AIMS@JCU/CoralSeaSymbionts/Coral-Sea-Cophylogeny-2025/ind_coords_iso.RData")
iso_seqs_host <- ind_coords_iso %>% 
  mutate("sample_name" = VialID)

#here is the subset with the data that matches the host data
load("~/AIMS@JCU/CoralSeaSymbionts/Coral-Sea-Cophylogeny-2025/all_data_iso.RData")
seq_data_iso <- all_data_iso %>% 
  filter(!str_detect(name, "non")) %>% 
  filter(!str_detect(name, "p_"))

shared_seqs_iso <- inner_join(iso_seqs_host, seq_data_iso, by = "sample_name")

seq_data_iso %>% 
  distinct(sample_name) %>% 
  nrow()
 #should be 187 in the symbiont

shared_seqs_iso <- shared_seqs_iso %>% 
  select(sample_name)
```

### 3.1.1 Host tree

```{r}
load("~/AIMS@JCU/CoralSeaSymbionts/Coral-Sea-Cophylogeny-2025/iso_gen.RData") #load host data

library(adegenet) #install required package
library(poppr)


# Check your individual names in iso_gen
ind_names_host_iso <- indNames(iso_gen)

# Subset the genind object to retain only matching individuals
iso_gen_subset <- iso_gen[ind_names_host_iso %in% shared_seqs_iso$sample_name, ]

length(indNames(iso_gen))          # Before 189
length(indNames(iso_gen_subset))   # After 188

#Compute the pairwise distances between multivariate observations; used on raw allele frequencies.
host_shared_dist_iso <- dist(iso_gen_subset, method = "euclidean") #calculate euclidean distance 

# convert the distance matrix to a dist object
host_dist_matrix_iso <- as.dist(host_shared_dist_iso)

#Create a matrix with only common sample names for symbiont
seqs_wide_symbiont <- seq_data_iso %>%
  select(sample_name, name, value) %>%
  filter(sample_name %in% shared_seqs_iso$sample_name) %>% 
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name") #187 samples

#k_tree_iso_symbiont <- kdist_iso_symbiont %>% phangorn::upgma()

load("~/AIMS@JCU/CoralSeaSymbionts/Coral-Sea-Cophylogeny-2025/kdist_iso_symbiont.RData")

k_unidist_symbiont <- GUniFrac(seqs_wide_symbiont, k_tree_iso_symbiont)   #GUniFrac calculates all the distances 
k_unidist_symbiont <- k_unidist_symbiont$unifracs

 # GUniFrac with alpha 0.5 (i.e Generalised UniFrac Distance)
du_iso_symbiont <- k_unidist_symbiont[, , "d_0.5"]   
dist_iso_symbiont <- as.dist(du_iso_symbiont, diag = FALSE)
```

### 3.1.2 Symbiont Tree 

```{r}
#convert host (H) and symbiont (P) distance trees as data matrices
H.dist_iso <- host_dist_matrix_iso %>% as.matrix()
P.dist_iso <- dist_iso_symbiont %>% as.matrix() 
```

```{r}
#must have same number of dimensions 
dim(H.dist_iso)
dim(P.dist_iso) #its really odd that the symbiont has 186 when the code running above has 187 sample names

# Subset to only the samples that are in both datasets
intersect_samples_row_iso <- intersect(rownames(H.dist_iso), rownames(P.dist_iso))
intersect_samples_col_iso <- intersect(colnames(H.dist_iso), colnames(P.dist_iso)) # The host data set had 189, and the symbiont had 186
P.dist_intersect_iso <- P.dist_iso[intersect_samples_row_iso, intersect_samples_col_iso]
H.dist_intersect_iso <- H.dist_iso[intersect_samples_row_iso, intersect_samples_col_iso ]

# Subset to only the samples that are in both datasets
intersect_samples_iso <- intersect(rownames(H.dist_intersect_iso), rownames(P.dist_intersect_iso))
P.dist_iso <- P.dist_intersect_iso
H.dist_iso <- H.dist_intersect_iso

#recheck dimensions - all good 
dim(P.dist_iso)
dim(H.dist_iso)
```

### 3.1.3 Perform Paco analysis

```{r, include = FALSE}
# Perform Procrustes analysis. logical that symbionts depend on the host. so X = host and Y = symbiont. 

paco.iso <- procrustes(H.dist_iso, P.dist_iso, symmetric = FALSE)

paco.iso2 <- procrustes(H.dist_iso, P.dist_iso, symmetric = TRUE)
summary(paco.iso)

summary(paco.iso2)

#symmetric = FALSE: This specifies that the Procrustes rotation can be non-orthogonal (i.e. generalised), meaning that it can include scaling and shearing transformations in addition to rotation and reflection. This allows for more flexible alignment between the two dissimilarity matrices, but may result in a less interpretable or meaningful alignment depending on the nature of the data.


#statistics check for residuals 
#paco error chart 
plot(paco.iso, kind = 1, type = "text")

#show paco residuals. higher numbers mean these are the samples that have high dissimilarity between the symbiont and host trees
plot(paco.iso, kind = 2, type = "text")
```

Number of objects: 186    Number of dimensions: 186 

Procrustes sum of squares:  
 1.563793e+07 
Procrustes root mean squared error: 
 289.9567 
Quantiles of Procrustes errors:
     Min       1Q   Median       3Q      Max 
166.5647 262.5309 276.9388 319.7066 392.3467
*sum of squares here is ridiculous (over 1 million)*

##### Symmetric = TRUE
Call:
procrustes(X = H.dist_iso, Y = P.dist_iso, symmetric = TRUE) 

Number of objects: 186    Number of dimensions: 186 

Procrustes sum of squares:  
 0.8709314 
Procrustes root mean squared error: 
 0.06842826 
Quantiles of Procrustes errors:
       Min         1Q     Median         3Q        Max 
0.03930838 0.06195592 0.06535609 0.07544908 0.09259175 


### 3.1.4 Isopora procrustes plot

```{r}
#transfer PC coords into dataframe for plotting  
hp.df.iso <- data.frame(rda1=paco.iso2$Yrot[,1],
rda2=paco.iso2$Yrot[,2],xrda1=paco.iso2$X[,1],
xrda2=paco.iso2$X[,2]) %>% 
  tibble::rownames_to_column(var = "Vial") 

library(readxl)
#Vial is the unique genotype for each coral sample. 
CoralSea2024_Metadata <- read_excel("CoralSea2024_Metadata.xlsx")
meta <- CoralSea2024_Metadata %>% 
  rename("VialID" = "sample_name",
         "Depth (m)"= "Depth")

#filter metadata to just reef
meta.reef <- meta %>% 
  select(sample_name, Reef) %>% 
  rename(sample_name = "Vial")

#left join the metadata to get reef into the dataframe 
hp.df.iso2 <- hp.df.iso %>% left_join(meta.reef)

#create plot 
procrust.iso <- ggplot(hp.df.iso2) +
  geom_segment(aes(x=rda1,y=rda2,xend=xrda1,yend=xrda2), size = .2) +
  geom_point(aes(x=rda1, y=rda2, shape = "Host", color = Reef)) +
  geom_point(aes(x=xrda1, y=xrda2, shape = "Symbiont", color = Reef)) +
  scale_shape_manual(name = "Groups", 
                     values = c("Host" = 19, "Symbiont" = 17)) +
  scale_colour_manual(values = reef_pal2) +
    theme(legend.position = "none") +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank()) +
  theme(aspect.ratio = 1) 

save(procrust.iso, file = "procrust.iso2.RData")
```
```{r}
procrust.iso
```

## 3.2 Montipora
```{r}
load("~/AIMS@JCU/CoralSeaSymbionts/Coral-Sea-Cophylogeny-2025/ind_coords_monti.RData")
monti_seqs_host <- ind_coords_monti %>% 
  mutate("sample_name" = VialID)
load("~/AIMS@JCU/CoralSeaSymbionts/Coral-Sea-Cophylogeny-2025/all_data_monti.RData")
seq_data_monti <- all_data_monti %>% 
  filter(!str_detect(name, "non")) %>% 
  filter(!str_detect(name, "p_"))

#here is the subset with the data that matches the host data
shared_seqs_monti <- inner_join(monti_seqs_host, seq_data_monti, by = "sample_name")

seq_data_monti %>% 
  distinct(sample_name) %>% 
  nrow()
 #should be 187 in the symbiont

shared_seqs_monti <- shared_seqs_monti %>% 
  select(sample_name)
```

### 3.2.1 Host tree
*note the step for calculating the host_shared_dist_matrix - this is the line we may need to change to get the procrustes looking a bit less like a straight line*
```{r}
load("~/AIMS@JCU/CoralSeaSymbionts/Coral-Sea-Cophylogeny-2025/monti_gen.RData") #load host data


library(adegenet) #install required package
library(poppr)


# Check your individual names in monti_gen
ind_names_host_monti <- indNames(monti_gen)

# Subset the genind object to retain only matching individuals
monti_gen_subset <- monti_gen[ind_names_host_monti %in% shared_seqs_monti$sample_name, ]

length(indNames(monti_gen))          # Before 180
length(indNames(monti_gen_subset))   # After 177

#Compute the pairwise distances between multivariate observations; used on raw allele frequencies.
host_shared_dist_monti <- dist(monti_gen_subset, method = "euclidean") #calculate euclidean distance 

# convert the distance matrix to a dist object
host_dist_matrix_monti <- as.dist(host_shared_dist_monti)

#Create a matrix with only common sample names for symbiont
seqs_wide_symbiont <- seq_data_monti %>%
  select(sample_name, name, value) %>%
  filter(sample_name %in% shared_seqs_monti$sample_name) %>% 
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name") #187 samples

#k_tree_monti_symbiont <- kdist_monti_symbiont %>% phangorn::upgma()

load("~/AIMS@JCU/CoralSeaSymbionts/Coral-Sea-Cophylogeny-2025/kdist_monti_symbiont.RData")
# GUniFrac with alpha 0.5 (i.e Generalised UniFrac Distance)
du_monti_symbiont <- k_unidist_monti[, , "d_0.5"]   
dist_monti_symbiont <- as.dist(du_monti_symbiont, diag = FALSE)

```

### 3.2.2 Symbiont Tree 

```{r}
#convert host (H) and symbiont (P) distance trees as data matrices
H.dist_monti <- host_dist_matrix_monti %>% as.matrix()
P.dist_monti <- dist_monti_symbiont %>% as.matrix() 
```

```{r}
#must have same number of dimensions 
dim(H.dist_monti)
dim(P.dist_monti) #its really odd that the symbiont has 186 when the code running above has 187 sample names

# Subset to only the samples that are in both datasets
intersect_samples_row_monti <- intersect(rownames(H.dist_monti), rownames(P.dist_monti))
intersect_samples_col_monti <- intersect(colnames(H.dist_monti), colnames(P.dist_monti)) # The host data set had 189, and the symbiont had 186
P.dist_intersect_monti <- P.dist_monti[intersect_samples_row_monti, intersect_samples_col_monti]
H.dist_intersect_monti <- H.dist_monti[intersect_samples_row_monti, intersect_samples_col_monti ]

# Subset to only the samples that are in both datasets
intersect_samples_monti <- intersect(rownames(H.dist_intersect_monti), rownames(P.dist_intersect_monti))
P.dist_monti <- P.dist_intersect_monti
H.dist_monti <- H.dist_intersect_monti

#recheck dimensions - all good 
dim(P.dist_monti)
dim(H.dist_monti)
```

### 3.1.3 Perform Paco analysis

```{r, include = FALSE}
# Perform Procrustes analysis. logical that symbionts depend on the host. so X = host and Y = symbiont. 

paco.monti <- procrustes(H.dist_monti, P.dist_monti, symmetric = FALSE)
summary(paco.monti)

#symmetric = FALSE: This specifies that the Procrustes rotation can be non-orthogonal (i.e. generalised), meaning that it can include scaling and shearing transformations in addition to rotation and reflection. This allows for more flexible alignment between the two dissimilarity matrices, but may result in a less interpretable or meaningful alignment depending on the nature of the data.


#statistics check for residuals 
#paco error chart 
plot(paco.monti, kind = 1, type = "text")

#show paco residuals. higher numbers mean these are the samples that have high dissimilarity between the symbiont and host trees
plot(paco.monti, kind = 2, type = "text")
```



### 3.2.4 montipora procrustes plot

```{r}
#transfer PC coords into dataframe for plotting  
hp.df.monti <- data.frame(rda1=paco.monti$Yrot[,1],
rda2=paco.monti$Yrot[,2],xrda1=paco.monti$X[,1],
xrda2=paco.monti$X[,2]) %>% 
  tibble::rownames_to_column(var = "Vial") 


#filter metadata to just reef
meta.reef <- meta %>% 
  select(sample_name, Reef) %>% 
  rename(sample_name = "Vial")

#left join the metadata to get reef into the dataframe 
hp.df.monti2 <- hp.df.monti %>% left_join(meta.reef)

#create plot 
procrust.monti <- ggplot(hp.df.monti2) +
  geom_segment(aes(x=rda1,y=rda2,xend=xrda1,yend=xrda2), size = .2) +
  geom_point(aes(x=rda1, y=rda2, shape = "Host", color = Reef)) +
  geom_point(aes(x=xrda1, y=xrda2, shape = "Symbiont", color = Reef)) +
  scale_shape_manual(name = "Groups", 
                     values = c("Host" = 19, "Symbiont" = 17)) +
  scale_colour_manual(values = reef_pal2) +
    theme(legend.position = "none") +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank()) +
  theme(aspect.ratio = 1) 

procrust.monti

save(procrust.monti, file = "procrust.monti.RData")
```
## 3.3 Acropora
```{r}
load("~/AIMS@JCU/CoralSeaSymbionts/Coral-Sea-Cophylogeny-2025/all_data_acro.RData")
load("~/AIMS@JCU/CoralSeaSymbionts/Coral-Sea-Cophylogeny-2025/ind_coords_acro.RData")

ind_coords_acro <- ind_coords
acro_seqs_host <- ind_coords_acro %>% 
  mutate("sample_name" = ind)

seq_data_acro <- all_data_acro %>% 
  filter(!str_detect(name, "non")) %>% 
  filter(!str_detect(name, "p_"))


#here is the subset with the data that matches the host data
shared_seqs_acro <- inner_join(acro_seqs_host, seq_data_acro, by = "sample_name")

seq_data_acro %>% 
  distinct(sample_name) %>% 
  nrow()
 #should be 354 in the symbiont

shared_seqs_acro <- shared_seqs_acro %>% 
  select(sample_name)
```

### 3.3.1 Host tree

```{r}
load("~/AIMS@JCU/CoralSeaSymbionts/Coral-Sea-Cophylogeny-2025/acro_gen.RData") #load host data
load("~/AIMS@JCU/CoralSeaSymbionts/Coral-Sea-Cophylogeny-2025/all_data_acro.RData") #load symbiont data
seq_data_acro <- all_data_acro %>% 
  filter(!str_detect(name, "non")) %>% 
  filter(!str_detect(name, "p_"))

library(adegenet) #install required package
library(poppr)


# Check your individual names in acro_gen
ind_names_host_acro <- indNames(acro_gen)

# Subset the genind object to retain only matching individuals
acro_gen_subset <- acro_gen[ind_names_host_acro %in% shared_seqs_acro$sample_name, ]

length(indNames(acro_gen))          # Before 379
length(indNames(acro_gen_subset))   # After 352

#Compute the pairwise distances between multivariate observations; used on raw allele frequencies.
host_shared_dist_acro <- dist(acro_gen_subset, method = "euclidean") #calculate euclidean distance 

# convert the distance matrix to a dist object
host_dist_matrix_acro <- as.dist(host_shared_dist_acro)

#Create a matrix with only common sample names for symbiont
seqs_wide_symbiont_acro <- seq_data_acro %>%
  select(sample_name, name, value) %>%
  filter(sample_name %in% shared_seqs_acro$sample_name) %>% 
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name") #379 samples

load("~/AIMS@JCU/CoralSeaSymbionts/Coral-Sea-Cophylogeny-2025/kdist_acro_symbiont.RData")
#k_tree_acro_symbiont <- kdist_acro_symbiont %>% phangorn::upgma()



k_unidist_symbiont_acro <- GUniFrac(seqs_wide_symbiont_acro, k_tree_acro_symbiont)   #GUniFrac calculates all the distances 
k_unidist_symbiont_acro <- k_unidist_symbiont_acro$unifracs


 # GUniFrac with alpha 0.5 (i.e Generalised UniFrac Distance)
du_acro_symbiont <- k_unidist_symbiont_acro[, , "d_0.5"]   
dist_acro_symbiont <- as.dist(du_acro_symbiont, diag = FALSE)
```

### 3.3.2 Symbiont Tree 

```{r}
#convert host (H) and symbiont (P) distance trees as data matrices
H.dist_acro <- host_dist_matrix_acro %>% as.matrix()
P.dist_acro <- dist_acro_symbiont %>% as.matrix() 
```

```{r}
#must have same number of dimensions 
dim(H.dist_acro)
dim(P.dist_acro) #its really odd that the symbiont has 186 when the code running above has 187 sample names

# Subset to only the samples that are in both datasets
intersect_samples_row_acro <- intersect(rownames(H.dist_acro), rownames(P.dist_acro))
intersect_samples_col_acro <- intersect(colnames(H.dist_acro), colnames(P.dist_acro)) # The host data set had 189, and the symbiont had 186
P.dist_intersect_acro <- P.dist_acro[intersect_samples_row_acro, intersect_samples_col_acro]
H.dist_intersect_acro <- H.dist_acro[intersect_samples_row_acro, intersect_samples_col_acro ]

# Subset to only the samples that are in both datasets
intersect_samples_acro <- intersect(rownames(H.dist_intersect_acro), rownames(P.dist_intersect_acro))
P.dist_acro <- P.dist_intersect_acro
H.dist_acro <- H.dist_intersect_acro

#recheck dimensions - all good 
dim(P.dist_acro)
dim(H.dist_acro)
```

### 3.1.3 Perform Paco analysis

```{r, include = FALSE}
# Perform Procrustes analysis. logical that symbionts depend on the host. so X = host and Y = symbiont. 

paco.acro <- procrustes(H.dist_acro, P.dist_acro, 
                        symmetric = TRUE)
#or symmetric = FALSE
summary(paco.acro)

#symmetric = FALSE: This specifies that the Procrustes rotation can be non-orthogonal (i.e. generalised), meaning that it can include scaling and shearing transformations in addition to rotation and reflection. This allows for more flexible alignment between the two dissimilarity matrices, but may result in a less interpretable or meaningful alignment depending on the nature of the data.


#statistics check for residuals 
#paco error chart 
plot(paco.acro, kind = 1, type = "text")

#show paco residuals. higher numbers mean these are the samples that have high dissimilarity between the symbiont and host trees
plot(paco.acro, kind = 2, type = "text")
```

Call:
procrustes(X = H.dist_acro, Y = P.dist_acro, symmetric = TRUE) 

Number of objects: 352    Number of dimensions: 352 

Procrustes sum of squares:  
 0.6773117 
Procrustes root mean squared error: 
 0.04386549 
Quantiles of Procrustes errors:
       Min         1Q     Median         3Q        Max 
0.01519683 0.02146343 0.02531260 0.03446136 0.15723155 


### 3.1.4 acropora procrustes plot

```{r}
#transfer PC coords into dataframe for plotting  
hp.df.acro <- data.frame(rda1=paco.acro$Yrot[,1],
rda2=paco.acro$Yrot[,2],xrda1=paco.acro$X[,1],
xrda2=paco.acro$X[,2]) %>% 
  tibble::rownames_to_column(var = "Vial") 

#code for defining specific colours per reef for procrustes plots later on
reef_pal2 <- c("#ac1917", "#e54a50", "#b75420", "#ea8553", "#c0982b", "#eec76b", "#768b45", "#a9be77", "#B2DFDB", "#4eaaa6", "#00798C")

reef_names <- c("Elizabeth", "Middleton", "Cato", "Wreck", "Kenn", "Mellish", "Marion","Frederick", "Saumarez", "Madgelaine", "NA")

names(reef_pal2) <- reef_names

#filter metadata to just reef
meta.reef <- meta %>% 
  select(sample_name, Reef) %>% 
  rename(sample_name = "Vial")

#left join the metadata to get reef into the dataframe 
hp.df.acro2 <- hp.df.acro %>% left_join(meta.reef)

#create plot 
procrust.acro <- ggplot(hp.df.acro2) +
  geom_segment(aes(x=rda1,y=rda2,xend=xrda1,yend=xrda2), size = .2) +
  geom_point(aes(x=rda1, y=rda2, shape = "Host", color = Reef)) +
  geom_point(aes(x=xrda1, y=xrda2, shape = "Symbiont", color = Reef)) +
  scale_shape_manual(name = "Groups", 
                     values = c("Host" = 19, "Symbiont" = 17)) +
  scale_colour_manual(values = reef_pal2) +
    theme(legend.position = "none") +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank()) +
  theme(aspect.ratio = 1) 

save(procrust.acro, file = "procrust.acro.RData")
```

```{r}
procrust.acro
```

