---
title: "Analysis_2025"
author: "M. Marzonie" "M. White"
date: "25/04/2025"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load Data

### Load Libraries

```{r, warning = FALSE, echo = FALSE, message=FALSE}
library(ggsci)
library(tidyverse)
library(dplyr)
library(forcats)
library(reshape2)
library(stringr)
library(tidyr)
library(tibble)
library(sangerseqR)
library(DECIPHER)
library(Biostrings)
library(phangorn)
library(ape)
library(ggplot2)
library(ggtree)
library(patchwork)
library(bioseq)
library(kmer)
library(GUniFrac)
library(seqinr)
library(vegan)
library(corrplot)
library(ggrepel)

library(ggmsa)
library(dendextend)
library(usedist)
```


### Load Symbiont Data
```{r, show_col_types = FALSE}
seqs_monti <- read_tsv("seqs.abs.monti.txt") %>% 
    filter(!(is.na(sample_name))) %>%
  dplyr::select(sample_name, `A1`:`G3ai`) %>% 
  mutate(sample_name = as.factor(sample_name)) %>% 
  filter(!grepl("-20", sample_name) & !grepl("b", sample_name))

seqs_monti

seqs_iso <- read_tsv("seqs.abs.Isopora.txt") %>% 
    filter(!(is.na(sample_name))) %>%
  dplyr::select(sample_name, `A1`:`G3ai`) %>% 
  mutate(sample_name = as.factor(sample_name)) %>% 
  filter(!grepl("-20", sample_name) & !grepl("b", sample_name))

seqs_iso

seqs_acro <- read_tsv("seqs.abs.acro.txt") %>% 
    filter(!(is.na(sample_name))) %>%
  dplyr::select(sample_name, `A1`:`G3ai`) %>% 
  mutate(sample_name = as.factor(sample_name)) %>% 
  filter(!grepl("-20", sample_name) & !grepl("b", sample_name))

seqs_acro
```


### Load Metadata

```{r}
library(readxl)
#Vial is the unique genotype for each coral sample. 
CoralSea2024_Metadata <- read_excel("CoralSea2024_Metadata.xlsx")

meta <- CoralSea2024_Metadata %>% 
  rename("VialID" = "sample_name",
         "Depth (m)"= "Depth")
```


### Load Custom Functions
```{r}
read_fasta_df <- function (file = "") {
  fasta <- readLines(file)
  ind <- grep(">", fasta)
  s <- data.frame(ind = ind, from = ind + 1, to = c((ind - 
    1)[-1], length(fasta)))
  seqs <- rep(NA, length(ind))
  for (i in 1:length(ind)) {
    seqs[i] <- paste(fasta[s$from[i]:s$to[i]], collapse = "")
  }
  tib <- tibble(label = gsub(">", "", fasta[ind]), sequence = seqs)
  return(tib)
}

write_fasta_df <- function (data, filename) 
{
    fastaLines = c()
    for (rowNum in 1:nrow(data)) {
        fastaLines = c(fastaLines, as.character(paste(">", 
            data[rowNum, "label"], sep = "")))
        fastaLines = c(fastaLines, as.character(data[rowNum, 
            "sequence"]))
    }
    fileConn <- file(filename)
    writeLines(fastaLines, fileConn)
    close(fileConn)
}

dna_to_DNAbin <- function (dna){
  DNAbin <- as_DNAbin(dna)
  names(DNAbin) <- names(dna)
  return(DNAbin)
}
dna_to_DNAStringset <- function(x) 
{
    bioseq:::check_dna(x)
    DNAstr <- DNAStringSet(paste(x))
    names(DNAstr) <- names(x)
    return(DNAstr)
}

DNAStringSet_to_dna <- function(x){
    x_dna <- as_dna(paste(x))
    names(x_dna) <- names(x)
    res <- tibble(label = names(x), sequence = x_dna)
    return(res)
}

# Convert DNAstringset to DNAbin
DNAStringSet_to_DNAbin <- function(DNAStringSet){
  DNAbin <- as.DNAbin(DNAStringSet)
  return(DNAbin)
}

# https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-018-2315-y
palette <- c("A" = "#46ff2d", 
             "G" = "#ffae01", 
             "C" = "#f24641", 
             "T" = "#4294fa", 
             "K" = "#8b4816",
             "M" = "#83831f",
             "R" = "#ffff81",
             "S" = "#ff9d80",
             "Y" = "#e381f2",
             "W" = "#80fff2",
             "V" = "#fde4b8",
             "B" = "#f9c1bf",
             "H" = "#c0d9f9",
             "D" = "#c7ffba",
             "U" = "#8989fb",
             "N" = "black", 
             "-" = "white",
             "+" = "White")


pal_df <- data.frame(names = names(palette), col = palette)
```

### Combining sequence/metadata 

# Montipora

```{r}
# Convert to long format
seqs_long_monti <- seqs_monti %>%
  filter(!is.na(sample_name)) %>%
  select(sample_name, `A1`:`G3ai`) %>%
  pivot_longer(`A1`:`G3ai`) %>%
  filter(value > 0) %>% # Remove zero values
  left_join(., meta)

# Q. Are we working with the post-med seqs according to the metadata in seqs?
san_check_monti <- seqs_long_monti %>%
  group_by(sample_name) %>%
  summarise(total = sum(value)) #A. yes

# Create a list of samples to keep that didnt fail to sequence
keepers_ss <- san_check_monti %>%
  filter(total > 1500)

non_keep <- san_check_monti %>% 
  filter(total < 1500)

#we filter out 2 samples with less than A142 and A191

# Filter out the failed samples
seqs_long_monti <- seqs_long_monti %>%
  filter(sample_name %in% keepers_ss$sample_name) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) %>% # Convert to relative abundance
  ungroup() %>%
  mutate(name = as.factor(name)) # Make sample names a factor

# Create a random palette for each sequence
n <- length(levels(seqs_long_monti$name))
seqs_pal = rainbow(n, s=.6, v=.9)[sample(1:n,n, replace = FALSE)]
names(seqs_pal) <- levels(seqs_long_monti$name)

# Read in the profile data
profiles_raw_monti <- read_tsv("profiles.abs.monti.txt", skip = 6) %>%
    select(sample_name = `...2`, `A1-A1qd-A1qe`:`G3fd`) %>%
    filter(!is.na(sample_name)) %>%
  select(sample_name, `A1-A1qd-A1qe`:`G3fd`)

#Convert to long format 
profiles_long_monti <- profiles_raw_monti %>%
  pivot_longer(`A1-A1qd-A1qe`:`G3fd`) %>% # Convert it to long format
  mutate(name = paste0("p_", name)) %>% # Add a p_ to the beginning of each profile (Some profiles are single sequence profiles and clash with the Sequence names)
  filter(sample_name %in% seqs_long_monti$sample_name) %>% # Remove samples that dont appear in the Sequence dataframe
  group_by(sample_name) %>%
  mutate(value = as.numeric(value)) %>%
  filter(value > 0) %>% # Remove 0 abundance profiles
  mutate(sample_name = as.factor(sample_name),
         name = as.factor(name)) %>% 
  ungroup() %>%
  left_join(., meta) # Add in metadata

# What is the total number of profile-related sequences in each sample?
profiles_sum_monti <- profiles_long_monti %>%
  group_by(sample_name) %>%
  summarise(total = sum(value))

# How many sequences in each sample are not part of a profile?
residual_monti <- left_join(profiles_sum_monti, san_check, by = "sample_name") %>%
  mutate(residual = total.y - total.x) %>%
  select(sample_name, value = residual) %>%
  mutate(name = "non-profile sequences") %>%
  left_join(., meta)

# Combine the profiles and non-profile sequences
profile_data_monti <- rbind(profiles_long_monti, residual) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) # convert to relative abundance - in that sample 

# Create palette for profiles (this is a darker palette)
n_monti <- length(levels(profile_data_monti$name))
profile_pal = rainbow(n, s=.6, v=.6)[sample(1:n,n, replace = FALSE)]
names(profile_pal) <- levels(profile_data_monti$name)

# Merge the palettes and replace the non-profile sequences with grey
all_pal <- c(seqs_pal, profile_pal)
all_pal['non-profile sequences'] <- "#808080" 

# Join profiles and sequence data together into single dataframe and add more metadata
all_data_monti <- rbind(seqs_long_monti, profile_data_monti) 

```


# Isopora
```{r Isopora}
# Convert to long format
seqs_long_iso <- seqs_iso %>%
  filter(!is.na(sample_name)) %>%
  select(sample_name, `A1`:`G3ai`) %>%
  pivot_longer(`A1`:`G3ai`) %>%
  filter(value > 0) %>% # Remove zero values
  left_join(., meta)

# Q. Are we working with the post-med seqs according to the metadata in seqs?
san_check_iso <- seqs_long_iso %>%
  group_by(sample_name) %>%
  summarise(total = sum(value)) #A. yes

# Create a list of samples to keep that didnt fail to sequence
keepers_ss <- san_check_iso %>%
  filter(total > 1500)

non_keep <- san_check_iso %>% 
  filter(total < 1500)

#we filter out 2 samples with less than A142 and A191

# Filter out the failed samples
seqs_long_iso <- seqs_long_iso %>%
  filter(sample_name %in% keepers_ss$sample_name) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) %>% # Convert to relative abundance
  ungroup() %>%
  mutate(name = as.factor(name)) # Make sample names a factor

# Create a random palette for each sequence
n <- length(levels(seqs_long_iso$name))
seqs_pal = rainbow(n, s=.6, v=.9)[sample(1:n,n, replace = FALSE)]
names(seqs_pal) <- levels(seqs_long_iso$name)

# Read in the profile data
profiles_raw_iso <- read_tsv("profiles.abs.Isopora.txt", skip = 6) %>%
    select(sample_name = `...2`, `A1`:`F4q`) %>%
    filter(!is.na(sample_name)) %>%
  select(sample_name, `A1`:`F4q`)

#Convert to long format 
profiles_long_iso <- profiles_raw_iso %>%
  pivot_longer(`A1`:`F4q`) %>% # Convert it to long format
  mutate(name = paste0("p_", name)) %>% # Add a p_ to the beginning of each profile (Some profiles are single sequence profiles and clash with the Sequence names)
  filter(sample_name %in% seqs_long$sample_name) %>% # Remove samples that dont appear in the Sequence dataframe
  group_by(sample_name) %>%
  mutate(value = as.numeric(value)) %>%
  filter(value > 0) %>% # Remove 0 abundance profiles
  mutate(sample_name = as.factor(sample_name),
         name = as.factor(name)) %>% 
  ungroup() %>%
  left_join(., meta) # Add in metadata

# What is the total number of profile-related sequences in each sample?
profiles_sum_iso <- profiles_long_iso %>%
  group_by(sample_name) %>%
  summarise(total = sum(value))

# How many sequences in each sample are not part of a profile?
residual_iso <- left_join(profiles_sum_iso, san_check, by = "sample_name") %>%
  mutate(residual = total.y - total.x) %>%
  select(sample_name, value = residual) %>%
  mutate(name = "non-profile sequences") %>%
  left_join(., meta)

# Combine the profiles and non-profile sequences
profile_data_iso <- rbind(profiles_long_iso, residual) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) # convert to relative abundance - in that sample 

# Create palette for profiles (this is a darker palette)
n_iso <- length(levels(profile_data_iso$name))
profile_pal = rainbow(n, s=.6, v=.6)[sample(1:n,n, replace = FALSE)]
names(profile_pal) <- levels(profile_data_iso$name)

# Merge the palettes and replace the non-profile sequences with grey
all_pal <- c(seqs_pal, profile_pal)
all_pal['non-profile sequences'] <- "#808080" 

# Join profiles and sequence data together into single dataframe and add more metadata
all_data_iso <- rbind(seqs_long_iso, profile_data_iso) 
```

```{r}
# How many samples per species?
all_data_iso %>%
  distinct(sample_name, Reef) %>%
  group_by(Reef) %>% 
  summarise(total_samples = n())

isopora_study_total <- all_data_iso %>% 
   filter(!(str_detect(name, "p_")),
         name != "non-profile sequences") %>% 
  summarise(total_seqs = sum(value)) %>%
  pull(total_seqs)

#9382894 sequences in isopora dataset
```

# Acropora

```{r Acropora}
# Convert to long format
seqs_long_acro <- seqs_acro %>%
  filter(!is.na(sample_name)) %>%
  select(sample_name, `A1`:`G3ai`) %>%
  pivot_longer(`A1`:`G3ai`) %>%
  filter(value > 0) %>% # Remove zero values
  left_join(., meta)

# Q. Are we working with the post-med seqs according to the metadata in seqs?
san_check <- seqs_long_acro %>%
  group_by(sample_name) %>%
  summarise(total = sum(value)) #A. yes

# Create a list of samples to keep that didnt fail to sequence
keepers_ss <- san_check %>%
  filter(total > 1500)

non_keep <- san_check %>% 
  filter(total < 1500)

#we filter out 2 samples with less than A142 and A191

# Filter out the failed samples
seqs_long_acro <- seqs_long_acro %>%
  filter(sample_name %in% keepers_ss$sample_name) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) %>% # Convert to relative abundance
  ungroup() %>%
  mutate(name = as.factor(name)) # Make sample names a factor

# Create a random palette for each sequence
n_acro <- length(levels(seqs_long_acro$name))
seqs_pal = rainbow(n, s=.6, v=.9)[sample(1:n,n, replace = FALSE)]
names(seqs_pal) <- levels(seqs_long$name)

# Read in the profile data
profiles_raw_acro <- read_tsv("profiles.abs.acro.txt", skip = 6) %>%
    select(sample_name = `...2`, `A1-A1gr-A1gd-A1mm-A1bf`:`D1-D17i-D17s-D1r-D17r`) %>%
    filter(!is.na(sample_name)) %>%
  select(sample_name, `A1-A1gr-A1gd-A1mm-A1bf`:`D1-D17i-D17s-D1r-D17r`)

#Convert to long format 
profiles_long_acro <- profiles_raw_acro%>%
  pivot_longer(`A1-A1gr-A1gd-A1mm-A1bf`:`D1-D17i-D17s-D1r-D17r`) %>% # Convert it to long format
  mutate(name = paste0("p_", name)) %>% # Add a p_ to the beginning of each profile (Some profiles are single sequence profiles and clash with the Sequence names)
  filter(sample_name %in% seqs_long$sample_name) %>% # Remove samples that dont appear in the Sequence dataframe
  group_by(sample_name) %>%
  mutate(value = as.numeric(value)) %>%
  filter(value > 0) %>% # Remove 0 abundance profiles
  mutate(sample_name = as.factor(sample_name),
         name = as.factor(name)) %>% 
  ungroup() %>%
  left_join(., meta) # Add in metadata

# What is the total number of profile-related sequences in each sample?
profiles_sum_acro <- profiles_long_acro %>%
  group_by(sample_name) %>%
  summarise(total = sum(value))

# How many sequences in each sample are not part of a profile?
residual_acro <- left_join(profiles_sum_acro, san_check, by = "sample_name") %>%
  mutate(residual = total.y - total.x) %>%
  select(sample_name, value = residual) %>%
  mutate(name = "non-profile sequences") %>%
  left_join(., meta)

# Combine the profiles and non-profile sequences
profile_data_acro <- rbind(profiles_long_acro, residual_acro) %>%
  group_by(sample_name) %>%
  mutate(value_rel = value/sum(value)) # convert to relative abundance - in that sample 

# Create palette for profiles (this is a darker palette)
n_acro <- length(levels(profile_data_acro$name))
profile_pal = rainbow(n, s=.6, v=.6)[sample(1:n,n, replace = FALSE)]
names(profile_pal) <- levels(profile_data$name)

# Merge the palettes and replace the non-profile sequences with grey
all_pal_acro <- c(seqs_pal, profile_pal)
all_pal['non-profile sequences'] <- "#808080" 

# Join profiles and sequence data together into single dataframe and add more metadata
all_data_acro <- rbind(seqs_long_acro, profile_data_acro) 

```

# 1 Library Stats

##1.1 Basic Stats

```{r}
# How many samples per species?
all_data <- bind_rows(all_data_acro, all_data_iso, all_data_monti) #combine all species 

all_data %>%
  distinct(sample_name, mtORF) %>%
  group_by(mtORF) %>% 
  summarise(total_samples = n())

# Acropora humulis
# Montipora spp
# Isopora
#Pocillopora

humil_total <- 
hap8a_total <- 
veru_total <- 
mean_total <- 

#remove unknowns from downstream analysis
clean_data <- all_data %>%
  filter(mtORF != "Unknown")

# Total number of sequences (for whole library)? 
study_total <- clean_data %>% 
   filter(!(str_detect(name, "p_")),
         name != "non-profile sequences") %>% 
  summarise(total_seqs = sum(value)) %>%
  pull(total_seqs)
	

#Total number of sequences (per species)? 
clean_data %>%
    filter(!(str_detect(name, "p_")),
         name != "non-profile sequences") %>% 
  group_by(mtORF) %>%
  summarise(total_seqs = sum(value))

# Acropora humulis
# Montipora spp
# Isopora
#Pocillopora

```


##1.2 Sequencing Depth
```{r}
# Average per sample sequencing depth? (per coral host genus, and per coral species)

# Average per sample across all spp
clean_data %>%
  group_by(sample_name) %>% 
  dplyr::summarise(per_sample = sum(value)) %>%
  dplyr::summarise(mean_all = mean(per_sample))
# Across all:  X

#average per sample per coral host genus 
clean_data %>%
  group_by(coral_genus, sample_name) %>% 
  summarise(per_sample = sum(value)) %>%
  summarise(mean_all = mean(per_sample), n = n())
# Acropora	X	
# Pocillopora	X


#average per sample per coral host species 
clean_data %>% 
  group_by(mtORF, sample_name) %>% 
  summarise(per_sample = sum(value)) %>%
  summarise(mean_all = mean(per_sample), n = n())
# Species
# Ahumilis	sum	mean		
# Haplotype8a	sum mean		
# Pmeandrina	sum mean		
# Pverrucosa	sum mean	
```

##1.3 Number of sequences per symbiont genus 
```{r}
# Total number of Cladocopium 
clean_data %>%
  filter(!(str_detect(name, "p_")), name != "non-profile sequences") %>%
  filter(str_sub(name, 1, 1) == "C" | str_detect(name, "_C")) %>% 
  summarise(sum = sum(value))
# sum	

(15335016 / study_total) * 100 # 99.98976 Clado

#Total number of Symbiodinium
clean_data %>%
  filter(!(str_detect(name, "p_")), name != "non-profile sequences") %>%
  filter(str_sub(name, 1, 1) == "A" | str_detect(name, "_A")) %>% 
  summarise(sum = sum(value)) 
# 1552	total seqs
(1552 / study_total) * 100 # 0.01011959 Symbio


# Total number of Durusdinium sequences
clean_data %>%
  filter(!(str_detect(name, "p_")), name != "non-profile sequences") %>%
  filter(str_sub(name, 1, 1) == "D" | str_detect(name, "_D")) %>% 
  summarise(sum = sum(value)) 
# 13 total reads

(13 / study_total) * 100 # 8.476463e-05 Durusdinium

```

##1.4 Characteristics of symbiont DIVs and Type Profiles 
```{r}
# general statements that apply to both species 

# what proportion of each sample are composed of non-profile sequences (grouped by coral host species)
clean_data %>%
  filter(str_detect(name, "non")) %>%
  group_by(mtORF) %>%
  summarise(mean = mean(value_rel))

# Ahumilis	mean relative value		
# Haplotype8a	mean relative value			
# Pmeandrina	mean relative value			
# Pverrucosa	mean relative value	


#proportion of non-profile sequences for each genus 
clean_data %>%
  filter(str_detect(name, "non")) %>%
  group_by(coral_genus) %>%
  summarise(mean = mean(value_rel))

# Acropora	mean proportion		
# Pocillopora	mean proportion

# Acropora has a lot more non-profile sequences than any Pocillopora. 
```


##1.5 Total number of Type Profiles 
```{r}
library(tidyverse)

#total type profiles across Acropora

#total type profiles across Isopora

#total type profiles across Montipora





```

##1.6 Type profile proportions
```{r}
#What is the proportion of samples that had 1 and 2 type profiles?

```

##1.7 Majority Sequences 
```{r}

```
##1.8 Depth Range
```{r}
#depth range and average/sd
meta %>% dplyr::select(c(Vial, Reef, mtORF, Lat, Depth)) %>% 
  filter(mtORF != "Unknown") %>% 
group_by(Vial) %>% 
  summarise(depth = mean(Depth)) %>% 
  summarise(sdvar = sd(depth))

meta %>% dplyr::select(c(Vial, Reef, mtORF, Lat, Depth)) %>% 
  filter(mtORF != "Unknown") %>% 
  group_by(mtORF) %>% 
  summarise(mindepth = min(Depth)) 

meta %>% dplyr::select(c(Vial, Reef, mtORF, Lat, Depth)) %>% 
  filter(mtORF != "Unknown") %>% 
  group_by(mtORF) %>% 
  summarise(maxdepth = max(Depth)) 

```

##Table S1.
```{r}
#How many samples collected from each reef, for each type of coral species? 
meta %>% dplyr::select(c(Vial, Reef, mtORF, Lat)) %>% 
  filter(mtORF != "Unknown") %>% 
  group_by(Reef, mtORF) %>% 
  summarise(total_samples = n()) %>%
  pivot_wider(names_from = mtORF, values_from = total_samples)
```


# 2 UPGMA Stats
Need to create a combined table here to make the seq data..
```{r}
#filter out non-profile sequences
seq_data <- clean_data %>% 
  filter(!str_detect(name, "non")) %>% 
  filter(!str_detect(name, "p_"))
  
#creating an object for each species 
poci_seqs <- seq_data %>% filter(coral_genus == "Pocillopora")
pver_seqs <- seq_data %>% filter(str_detect(mtORF, "Pverrucosa"))
pmh8_seqs <- seq_data %>% filter(str_detect(mtORF, "Pmeandrina|Haplotype8a"))
acro_seqs <- seq_data %>% filter(str_detect(mtORF, "Ahumilis"))

#colour palette
# Merge the palettes and replace the non-profile sequences with grey
all_pal <- c(seqs_pal, profile_pal)
all_pal['non-profile sequences'] <- "#808080" 
```


```{r}
seq_data %>% distinct(Reef)
```


## 2.1 Poci UPGMA Tree
```{r}

```

## Fig 2A
```{r}
bar_uni_poci <- 
ggplot(plot_df_poci, aes(Vial, value_rel)) +
geom_bar(stat = "identity", aes(fill = name, colour = name)) +
theme(aspect.ratio = 0.5, legend.position = "none", axis.text.y=element_blank(), axis.ticks.y = element_blank(),
      axis.text.x=element_blank(), axis.ticks.x = element_blank(),
      axis.title.x = element_blank(), axis.title.y = element_blank(),
      panel.border = element_blank(), panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), axis.ticks = element_blank()) +
scale_fill_manual(values = all_pal, breaks = levels(profile_data$name)) +
scale_colour_manual(values = all_pal, breaks = levels(profile_data$name)) +
geom_hline(yintercept = 1, linewidth = 1) +
guides(fill=guide_legend(ncol=2))

bar_uni_poci 


#p_bar_uni is the sequences by colour. P_tree_tip is the tree coloured by reef.

poci_tree_mat / bar_uni_poci
```


## 2.1.2 Acropora distance matrix
```{r}

```

##2.1.3 Isopora distance matrix
```{r}

```

##2.1.3 Montipora distance matrix
```{r}

```


#2.2 Isopora UPGMA Tree

```{r}
fasta_iso_symbioant <- read_fasta_df("seqs.isopora.fasta") %>% 
   filter(label %in% seqs_long_iso$name) %>%   #only keeping DNA seqs that appear in seqs_long subset 
  deframe() %>%
  as_dna()
 
#creating the tree
kdist_iso_symbioant <- fasta_iso_symbioant %>%
  dna_to_DNAbin() %>%
  kdistance(k = 7, residues = "DNA", method = "edgar") %>%
  as.matrix()
```

```{r}
#k_tree_iso_symbioant <- kdist_iso_symbioant %>% phangorn::upgma()

#k_tree_iso_symbioant

#save(k_tree_iso_symbioant, file = "kdist_iso_symbioant.RData")
load("~/AIMS@JCU/CoralSeaSymbioants/ITS2_Isopora_CS_2024/kdist_iso_symbioant.RData")
```
```{r}
seqs_wide_iso_symbioant <- seq_data_iso %>%
  dplyr::select(sample_name, name, value) %>%
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "sample_name")

head(seqs_wide_iso_symbioant)
```


## Fig 2B
tree / bar
```{r}


#p_bar_uni is the sequences by colour. P_tree_tip is the tree coloured by reef. 


```


### 2.2.2 K groups for Acropora 
```{r}
#there is clear division of symbiont communities. we will identify which k-group and then see how non-profile sequences vary between the two groups - which seems to be the predominant feature in the split. 

# Cluster the samples


# Get a sample order from ggtree


# Make the sample tree


```

###2.2.3 Extracting Kgroups Acro
```{r}
library(dendextend)

#here we are taking the output of the upgma for acropora which clusters samples by unifrac distance and putting it into 'cutree' 
#k value is how many groups you want membership for. We need to set k to 10 because each of the outliers form their own distinct k groups. 
cu_acro <- cutree(hclust_samps_acro, k = 10)
#cutree gives a named vector with sample sames and their membership to groups (1-8 in this case)

hclust_samps_acro %>% 
  as.dendrogram() %>% 
  set("branches_k_color", k = 10, value = pal_d3("category10")(10)) %>% 
  plot(main = "Group membership")


kvalue_acro <- enframe(cu_acro) %>% 
  dplyr::rename(kgroup = value) %>% 
  dplyr::rename(sample_name = name)

#save(kvalue_acro, file = "kvalue_acro.RData")
#change value to k group. add to metadata 

#k-group stats for acropora (k groups 1 and 2)
#joining clean data with the kgroups for acropora 
#clean_data <- left_join(clean_data, kvalue_acro)

#save(clean_data, file = "clean_data.RData")

#differences in k-group non-profile sequences 
#clean_data %>%
  #filter(str_detect(name, "non")) %>%
  #filter(coral_genus == "Acropora") %>% 
  #group_by(kgroup) %>%
 # summarise(mean = mean(value_rel)) #%>% 
  #summarise(n =n()) 

#non-profile abundance in the two difference clusters (1 = left side of tree, 2 = right side of tree)
# kgroup1	0.20711430			
# kgroup2	0.29029638

#t_df <- clean_data %>%
  #filter(str_detect(name, "non")) %>%
  #filter(coral_genus == "Acropora") %>% 
  #filter(kgroup == 1 | kgroup  == 2)

#t_df %>% 
  #rstatix::t_test(value_rel ~ kgroup)
```



# 3 Marker alignment psbAncr
```{r}
#psba txt files forward and reverse

```

## 3.1 Trimming parameters psba
```{r}
# apply the trimming parameters to start and end of the sequences to improve consensus

```


##3.2 Exclude list

```{r}
# Sample list that we may want to exclude based on f and r alignments: 
```


##3.3 Create the consensus sequences

```{r}

```

##3.4 Pocillopora psba
```{r}


# Keep only the pocillo psba sequences

```


###3.4.2 Poci: ITS2/psba distance matrices
```{r}
# Get consensus seqs
pocillo_df <- data.frame()
for(i in 1:length(pocillo_cons)){
  pocillo_cons[[i]] %>% writeXStringSet("temp_file.fasta")
  t_df <- read_fasta_df("temp_file.fasta")
  pocillo_df <- rbind(pocillo_df, t_df)
}

# Kmer based distance matrix
dis_psbaID <- pocillo_df %>%
  mutate(psba_ID = str_sub(label, 17, 25)) %>%
  left_join(., pocillo_meta) %>%
  select(Vial, sequence) %>%
  deframe() %>%
  DNAStringSet() %>%
  DNAStringSet_to_DNAbin() %>%
  kmer::kdistance(k = 7) %>%
  as.matrix()

# Produce hierarchical tree
psba_upgma_tree <- phangorn::upgma(dis_psbaID)

# Subset the full matrix
du_poci_sub <- dist_subset(du_poci, psba_upgma_tree$tip.label) %>%
  as.matrix()

# Produce hierarchical tree
ITS2_upgma_tree <- phangorn::upgma(du_poci_sub)
```

###3.4.3 Pocillopora ITS2 Tanglegram
```{r}
untang <- untangle(dend1 = ITS2_upgma_tree %>% as.dendrogram(), dend2 = psba_upgma_tree %>% as.dendrogram, method = "step2side")
tgram <- tanglegram(untang, margin_inner = 8)
entanglement(tgram) # 0.01193893

t_order <- labels(tgram$dend1)
s_order <- labels(tgram$dend2)

tt <- as.phylo(tgram$dend1)
tt <- midpoint(tt)

st <- as.phylo(tgram$dend2)
st <- midpoint(st)

tree_meta <- pocillo_meta %>%
  filter(Vial %in% psba_upgma_tree$tip.label) %>%
  mutate(new_lab = paste0(Vial, "_", mtORF))

gtt <- ggtree(tt, ladderize = FALSE) 
gtt$data <- gtt$data %>% left_join(., tree_meta, by = c("label" = "sample_name"))

gtt <- gtt + geom_tiplab(size = 3, aes(label = label)) + geom_tippoint(aes(fill = mtORF), shape = 21, size = 5) + ggsci::scale_fill_d3(palette = "category20")
gst <- ggtree(st, ladderize = FALSE)

dtt <- gtt$data
dst <- gst$data

dtt$tree <- "ITS2"
dst$tree <- "psbA"

dst$x <- max(dst$x) - dst$x + max(dtt$x) + max(dtt$x) * 1

pp <- gtt + geom_tree(data = dst)

dd <- bind_rows(dtt, dst) %>%
  filter(isTip == TRUE)

dd1 <- as.data.frame(dd)

p_ip <- pp + geom_line(aes(x, y, group = label), size = 1.2, data = dd1) +
  ggsci::scale_colour_d3(palette = "category20") +
  theme(legend.position = "none")

p_ip
```


##3.5 Acropora psba
```{r}

```

###3.5.2 Acro: ITS2/psbA distance matrices

```{r}
# Get consensus seqs


# Kmer based distance matrix


# Produce hierarchical tree


# Subset the full matrix


# Produce hierarchical tree

```

###3.5.3 Acropora ITS2 Tanglegram

```{r}
untang <- untangle(dend1 = ITS2_upgma_tree %>% as.dendrogram(), dend2 = psba_upgma_tree %>% as.dendrogram, method = "step2side")
tgram <- tanglegram(untang, margin_inner = 8)
entanglement(tgram) # 0.1986148

t_order <- labels(tgram$dend1)
s_order <- labels(tgram$dend2)

tt <- as.phylo(tgram$dend1)
tt <- midpoint(tt)

st <- as.phylo(tgram$dend2)
st <- midpoint(st)

tree_meta <- acro_meta %>%
  filter(sample_name %in% psba_upgma_tree$tip.label) %>%
  mutate(new_lab = paste0(Vial, "_", mtORF))

gtt <- ggtree(tt, ladderize = FALSE) 
gtt$data <- gtt$data %>% left_join(., tree_meta, by = c("label" = "sample_name"))

gtt <- gtt + geom_tiplab(size = 3, aes(label = label))
gst <- ggtree(st, ladderize = FALSE)

dtt <- gtt$data
dst <- gst$data

dtt$tree <- "ITS2"
dst$tree <- "psbA"

dst$x <- max(dst$x) - dst$x + max(dtt$x) + max(dtt$x) * 1

pp <- gtt + geom_tree(data = dst)

dd <- bind_rows(dtt, dst) %>%
  filter(isTip == TRUE)

dd1 <- as.data.frame(dd)

p_ip <- pp + geom_line(aes(x, y, group = label), size = 1.2, data = dd1)

tgram <- tanglegram(untang, margin_inner = 8)
p_ip
```


# 4 PCoAs
**Here we are running a PCoA on UniFrac distances for the three communities associated with three different host groups (Pocillopora verrucosa, P. meandrina, and Acropora humilis) to look for patterns by reef in symbiont community structure** 

##4.1 PCoA by Reef

###4.1.1 Pver Reef PCoA
```{r}
reef_order <- meta %>% distinct(Reef, Lat) %>%
  group_by(Reef) %>%
  summarise(Lat = mean(Lat)) %>%
  arrange(Lat) %>%
  pull(Reef)

pcoa_pver <- cmdscale(dist_pver, eig = TRUE) #this is doing 'cmds' or classic multidimensional scaling

ordiplot(pcoa_pver, display = 'sites', type = 'text')
barplot(pcoa_pver$eig, names = paste ('PCoA', 1:152), las = 3, ylab = 'eigenvalues')

# Custom x and y labels
xlab = paste("Axis 1 (1.4%)")
ylab = paste("Axis 2 (0.5%)")

MDSxy.pver <- data.frame(pcoa_pver$points) %>% 
  rownames_to_column(var = "Vial") %>% 
  left_join(., meta)

pverPCA <- MDSxy.pver %>%
  mutate(Reef = fct_relevel(Reef, reef_order)) %>%
  ggplot(aes(X1, X2, fill = Reef)) + 
  geom_point(alpha = 1, shape = 21, size = 3) + 
  scale_fill_viridis_d(option = "magma", direction = -1) +
   theme(legend.position = "none", aspect.ratio = 1, text = element_text(size = 15))

pverPCA
```


```{r}
# Extract the eigenvalues
eigenvalues <- pcoa_pver$eig

# Variance explained by the first PC
variance_explained_by_PC1 <- eigenvalues[1]

# Variance explained by the second PC
variance_explained_by_PC2 <- eigenvalues[2]

# Print the results
cat("Variance explained by the first PC: ", variance_explained_by_PC1, "\n")
cat("Variance explained by the second PC: ", variance_explained_by_PC2, "\n")
```


###4.1.2 Pmea Reef PCoA
```{r}
pcoa_pmh8 <- cmdscale(dist_pmh8, eig = TRUE)    #this is doing 'cmds' or classic multidimensional scaling

ordiplot(pcoa_pmh8, display = 'sites', type = 'text')
barplot(pcoa_pmh8$eig, names = paste ('PCoA', 1:172), las = 3, ylab = 'eigenvalues')

# Custom x and y labels
xlab = paste("Axis 1 (2.4%)")
ylab = paste("Axis 2 (1.1%)")

MDSxy.pmh8 <- data.frame(pcoa_pmh8$points) %>% 
  rownames_to_column(var = "Vial") %>% 
  left_join(., meta)

pmh8PCA <- MDSxy.pmh8 %>%
  mutate(Reef = fct_relevel(Reef, reef_order)) %>%
  ggplot(aes(X1, X2, fill = Reef)) + 
  geom_point(alpha = 1, shape = 21, size = 3) + 
  scale_fill_viridis_d(option = "magma", direction = -1) +
   theme(legend.position = "none", aspect.ratio = 1, text = element_text(size = 15))

pmh8PCA
```


```{r}
# Extract the eigenvalues
eigenvalues <- pcoa_pmh8$eig

# Variance explained by the first PC
variance_explained_by_PC1 <- eigenvalues[1]

# Variance explained by the second PC
variance_explained_by_PC2 <- eigenvalues[2]

# Print the results
cat("Variance explained by the first PC: ", variance_explained_by_PC1, "\n")
cat("Variance explained by the second PC: ", variance_explained_by_PC2, "\n")
```



###4.1.3 Acro Reef PCoA
```{r}
pcoa_acro <- cmdscale(dist_acro, eig = TRUE)    #this is doing 'cmds' or classic multidimensional scaling

outlier_samples <- c("A ten 298", "A ten 303", "A ten 302", "A ten 231", "A ten 225", "A ten 295", "A ten 223", "A ten 012")

ordiplot(pcoa_acro, display = 'sites', type = 'text')
barplot (pcoa_acro$eig, names = paste ('PCoA', 1:260), las = 3, ylab = 'eigenvalues')

# Custom x and y labels
xlab = paste("Axis 1 (5.0%)")
ylab = paste("Axis 2 (2.1%)")

MDSxy.acro <- data.frame(pcoa_acro$points) %>% 
  rownames_to_column(var = "Vial") %>% 
  left_join(., meta) %>% 
   mutate(catBleaching = as.factor(catBleaching)) %>% 
  filter(!(Vial %in% outlier_samples)) 

acroPCA <- MDSxy.acro %>%
  mutate(Reef = fct_relevel(Reef, reef_order)) %>%
  ggplot(aes(X1, X2, fill = Reef)) + 
  geom_point(alpha = 1, shape = 21, size = 3) + 
  scale_fill_viridis_d(option = "magma", direction = -1) 
 # scale_fill_manual(values = reef_pal) #+
 #theme(legend.position = "none", aspect.ratio = 1, text = element_text(size = 15))

acroPCA
```


```{r}
# Extract the eigenvalues
eigenvalues <- pcoa_acro$eig

# Variance explained by the first PC
variance_explained_by_PC1 <- eigenvalues[1]

# Variance explained by the second PC
variance_explained_by_PC2 <- eigenvalues[2]

# Print the results
cat("Variance explained by the first PC: ", variance_explained_by_PC1, "\n")
cat("Variance explained by the second PC: ", variance_explained_by_PC2, "\n")
```



### Fig SX PCoA Reef
```{r}
pverPCA + pmh8PCA + acroPCA
```


## 4.2 PCoA by Bleaching

###4.2.1 Pver Bleaching PCA
```{r}
library("RColorBrewer")
my_colors <- c("#F5F5F5", "#F6E8C3", "#DFC27D", "#BF812D", "#8C510A", "#543005")


MDSxy.pver.b <- data.frame(pcoa_pver$points) %>% 
  rownames_to_column(var = "Vial") %>% 
  left_join(., meta) %>% 
      mutate(catBleaching = as.factor(catBleaching))


pverPCA.b <- MDSxy.pver.b %>%
  ggplot(aes(X1, X2, fill = catBleaching)) + 
  geom_point(alpha = 1, shape = 21, size = 3) +
  scale_fill_manual(values = my_colors) +
    theme(legend.position = "none") 

pverPCA.b
```

###4.2.2 Pmea Bleaching PCA
```{r}
MDSxy.pmh8.b <- data.frame(pcoa_pmh8$points) %>% 
  rownames_to_column(var = "Vial") %>% 
  left_join(., meta) %>% 
      mutate(catBleaching = as.factor(catBleaching))

pmh8PCA.b <- MDSxy.pmh8.b %>%
  ggplot(aes(X1, X2, fill = catBleaching)) + 
  geom_point(alpha = 1, shape = 21, size = 3) +
  scale_fill_manual(values = my_colors) +
  theme(legend.position = "none") 

pmh8PCA.b
```

###4.2.3 Acro Bleaching PCA
```{r}
pcoa_acro.b <- cmdscale(dist_acro, eig = TRUE)    #this is doing 'cmds' or classic multidimensional scaling
outlier_samples <- c("A ten 298", "A ten 303", "A ten 302", "A ten 231", "A ten 225", "A ten 295", "A ten 223", "A ten 012")

MDSxy.acro.b <- data.frame(pcoa_acro.b$points) %>% 
  rownames_to_column(var = "Vial") %>% 
  left_join(., meta) %>% 
   mutate(catBleaching = as.factor(catBleaching)) %>% 
  filter(!(Vial %in% outlier_samples)) 

acroPCA.b <- MDSxy.acro.b %>%
  ggplot(aes(X1, X2, fill = catBleaching)) + 
  geom_point(alpha = 1, shape = 21, size = 3) +
  theme(legend.position = "right", aspect.ratio = 1, text = element_text(size = 10)) +
     scale_fill_manual(values = my_colors)

acroPCA.b
```

### Fig SX PCA Bleaching 
```{r}
#final figure for bleaching category PCoA 
PCA_bleach <- pverPCA.b + pmh8PCA.b + acroPCA.b 
PCA_bleach
```



## 4.3 PCoA by Admixture
**Here we are looking at the host genetic clustering (admixture proportion) and whether this structures the symbiont communities for each species** 

### 4.3.1 Pver Admixture PCoA
```{r}
##Looking at whether cluster from dartseq is important factor in symbiont communities in pver. Note we did not sequence haplotype 8a 
load("HostAdmix/qlong.admix.pver.RData")

qlong.admix.pver <- qlong.admix.pver %>% 
  mutate(Ind = as.factor(Ind)) %>% 
   dplyr::rename(Vial = Ind)


MDS.admix.pver <- MDSxy.pver.b %>% left_join(qlong.admix.pver)

pver.admixPCA <- MDS.admix.pver %>%
  ggplot(aes(X1, X2, fill = value)) + 
  geom_point(alpha = 1, shape = 21, size = 3) +
      scale_fill_distiller(palette = "YlOrRd") +
  theme(legend.position = "none") +
      theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank())
 #theme(legend.position = "right", aspect.ratio = 1, text = element_text(size = 15))      
pver.admixPCA 
```

### 4.3.2 Pmea Admixture PCoA
```{r}
##Looking at whether cluster from dartseq is important factor in symbiont communities in pver. Note we did not sequence haplotype 8a 
load("HostAdmix/qlong.admix.pmea.RData")

qlong.admix.pmea <- qlong.admix.pmea %>% 
  mutate(Ind = as.factor(Ind)) %>% 
   dplyr::rename(Vial = Ind)


MDS.admix.pmea <- MDSxy.pmh8 %>% left_join(qlong.admix.pmea)

pmea.admixPCA <- MDS.admix.pmea %>%
  ggplot(aes(X1, X2, fill = value)) + 
  geom_point(alpha = 1, shape = 21, size = 3) +
      scale_fill_distiller(palette = "YlOrRd") +
  theme(legend.position = "none") +
      theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank())
 #theme(legend.position = "right", aspect.ratio = 1, text = element_text(size = 15))      
pmea.admixPCA 
```

### 4.3.3 Acro Admixture PCoA
```{r}
#looking only at Cluster 3 of Acropora humilis - there were 3 distinct clusters found which correlate to the 3 different morphotypes. 

load("HostAdmix/qlong.admix.acroC3.RData")

qlong.admix.acroC3 <- qlong.admix.acroC3 %>% 
  mutate(Ind = as.factor(Ind)) %>% 
   dplyr::rename(Vial = Ind)


MDS.admix.acroC3 <- MDSxy.acro.b %>% left_join(qlong.admix.acroC3)

acro.admixPCA.C3 <- MDS.admix.acroC3 %>%
  ggplot(aes(X1, X2, fill = value)) + 
  geom_point(alpha = 1, shape = 21, size = 3) +
    scale_fill_distiller(palette = "YlOrRd") +
   theme(legend.position = "right", aspect.ratio = 1, text = element_text(size = 15)) +
    theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank())
  
acro.admixPCA.C3 
```

### Admixture figure 
```{r}
#this shows how symbiont communities are structured by admixture, for each of the three host species. 
PCA_admix <- pver.admixPCA  + pmea.admixPCA + acro.admixPCA.C3
PCA_admix
```

## 4.4 PCoA haplotype (Pmea)
```{r}
#this shows that there is no effect of haplotype 8a/ p. meandrina on symbiont communities, but we do see admixture clusters of P. meandrina are more important. 
MDSxy.pmh8.b <- data.frame(pcoa_pmh8$points) %>% 
  rownames_to_column(var = "Vial") %>% 
  left_join(., meta) 


pmh8PCA.b <- MDSxy.pmh8.b %>%
  ggplot(aes(X1, X2, fill = mtORF)) + 
  geom_point(alpha = 1, shape = 21, size = 3) +
        scale_fill_brewer(palette = "Spectral") +
 theme(legend.position = "right", aspect.ratio = 1, text = element_text(size = 15))


pmh8PCA.b
```


# 5 dbRDA 
**Here, we test UniFrac distances with environmental co-variates using distance-based RDA. We will use individual-based variables (depth, bleaching condition, and host genotype), biogeographic variable (latitude), DHW at time of collection (current disturbance)DHW 2020), and a long-term disturbance variable (max DHW 1986 - 2020)** 

```{r}
#first we need to add in kd490 (light attenuation) as per reviewer comments, so not in the initial metadata 
symbiont.light = read.csv("symbiont.light.csv") 
symbiont.light <- symbiont.light %>% dplyr::select(c(Aggregated.Date.Time, Variable, Depth, Site.Name, Latitude, Longitude, mean)) %>% 
  mutate(Variable = as.factor(Variable))

symbiont.light %>% pivot_wider(names_from = Variable, values_from = mean)


averaged_data <- symbiont.light %>%
  group_by(Site.Name, Aggregated.Date.Time, Depth, Variable) %>%
  summarize(mean_value = mean(mean)) %>%
  group_by(Site.Name, Variable) %>%
  summarize(mean_by_variable = mean(mean_value)) %>%
  pivot_wider(names_from = Variable, values_from = mean_by_variable) %>%
  ungroup()

light.data <- averaged_data %>% dplyr::select(c(Site.Name, Chl_a_sum, Kd_490)) %>% 
  mutate(Reef = as.factor(Site.Name)) %>% 
  dplyr::select(c(Reef,Kd_490))

```

## 5.1 Pver dbRDA
```{r}

```

```{r}

```



## 5.2 Pmea dbRDA
```{r}
#importing unifrac distances for analysis 
meta_pmh8 <- meta %>%
    left_join(., light.data) %>% 
  filter(mtORF == "Pmeandrina" | mtORF == "Haplotype8a") %>%
  filter(sample_name %in% keepers_ss$sample_name) %>%
  mutate(catBleaching = as.numeric(catBleaching)) %>%
  tibble::column_to_rownames(var = "Vial") %>%
  mutate(Vial = rownames(.))


#save(meta_pmh8, file = "meta_pmh8.RData")


dist_pmh8_ordered <- as.dist(as.matrix(dist_pmh8)[rownames(meta_pmh8), rownames(meta_pmh8)])

# Make a correlation matrix of numeric variables
cm <- cor(meta_pmh8 %>% dplyr::select(Depth, maxDHW, MMM, DHW2020, Lat, Long))

#check correlations visually 
corrplot(cm) 
cm %>% cor()

# Check the vif scores of the full model
ord_pmh8_full <- dbrda(dist_pmh8_ordered ~ Lat + Long + MMM + Depth + catBleaching + DHW2020 + maxDHW + Kd_490, data = meta_pmh8)

sort(vif.cca(ord_pmh8_full)) 
#catBleaching        Depth       maxDHW      DHW2020         Long          Lat          MMM 
   # 1.123412     1.246164     2.469619     5.601568    19.690299    20.097697    28.867819 

# Reduce the model (consult the corplot and vif scores). We will omit Long and MMM, and latitude will reflect overall biogeographic patterns 
ord_pmh8 <- dbrda(dist_pmh8_ordered ~ Lat + Depth + catBleaching + DHW2020 + maxDHW + Kd_490, data = meta_pmh8)

sort(vif.cca(ord_pmh8)) 

#catBleaching        Depth       maxDHW       Kd_490      DHW2020          Lat 
   # 1.118488     1.240862     1.581147     1.869206     5.144462     6.590704 

# Use ordistep to run a backward stepwise model. This will reduce the model to the most significant parameters 
os_pmh8_backward <- ordistep(ord_pmh8, direction = "backward", permutations = 999)
anova(os_pmh8_backward, by = 'margin')

#Model: dbrda(formula = dist_pmh8_ordered ~ Lat + catBleaching + maxDHW + Kd_490, data = meta_pmh8)
    #         Df SumOfSqs       F Pr(>F)    
#Lat            1   0.1981  8.5613  0.001 ***
#catBleaching   1   0.2376 10.2683  0.001 ***
#maxDHW         1   0.1141  4.9306  0.003 ** 
#Kd_490         1   0.0589  2.5470  0.058 .  
#Residual     167   3.8637                   7               

summary(ord_pmh8)


R2adj <- RsquareAdj(ord_pmh8)$adj.r.squared
R2adj 
#[1] 0.1888987

#variance partitioning to see how much variation is explained by each factor 
varp <- varpart(dist_pmh8_ordered, ~Lat, ~catBleaching, ~maxDHW, data = meta_pmh8)
plot(varp, digits = 2, Xnames = c("Lat", "catBleaching", "maxDHW"), bg = c("navy", "tomato", "green"))

#extract dbRDA scores
pmh8_scores <- as.data.frame(scores(os_pmh8_backward, display = "sites")) %>%
  tibble::rownames_to_column(var = "Vial") %>%
  left_join(., meta_pmh8)

#extract dbRDA vectors
pmh8_vectors <- as.data.frame(os_pmh8_backward$CCA$biplot) %>%
  tibble::rownames_to_column(var = "factors")

#produce dbRDA plot 
pmh8_fullrda <- pmh8_scores %>%
  mutate(Reef = fct_relevel(Reef, reef_order)) %>%
    ggplot(aes(x = dbRDA1, y = dbRDA2)) +
      geom_point(aes(fill = Lat), size = 3, shape = 21) +
      geom_label_repel(data = pmh8_vectors, aes(x = dbRDA1, y = dbRDA2, label = factors), box.padding = 0.75, size = 4, segment.colour = NA) +
      geom_segment(data = pmh8_vectors, aes(x = 0, xend = dbRDA1, y = 0, yend = dbRDA2), 
      size = 0.5, arrow = arrow(length = unit(0.5, "cm")), colour = "royalblue2") +
      scale_fill_viridis_c(option = "magma", direction = -1) +
  theme(aspect.ratio = 1, text = element_text(size = 15)) +
  theme(legend.position = "none") +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank())


pmh8_fullrda
```

## 5.3 Acro dbRDA
```{r}
#list outlier samples
outlier_samples <- c("Plate6_D012", "Plate6_E009", "Plate6_H011", "Plate6_B012", "Plate7_D006", "Plate6_G009", "Plate7_H009", "Plate7_A010", "Plate6_D011")

#importing unifrac distances for analysis 
meta_acro <- meta %>%
      left_join(., light.data) %>% 
  filter(mtORF == "Ahumilis") %>%
  filter(sample_name %in% keepers_ss$sample_name) %>%
  filter(!(sample_name %in% outlier_samples)) %>%
  tibble::column_to_rownames(var = "Vial") %>%
  mutate(Vial = rownames(.))

#save(meta_acro, file = "meta_acro.RData")


#combine Unifrac distances with enviro. data.
dist_acro_ordered <-  as.dist(as.matrix(dist_acro)[rownames(meta_acro), rownames(meta_acro)])

# Make a correlation matrix of numeric variables
cm <- cor(meta_acro %>% dplyr::select(Depth, maxDHW, MMM, DHW2020, Lat, Long))

#check correlations visually 
corrplot(cm) 
cm %>% cor()

# Check the vif scores of the full model
ord_acro_full <- dbrda(dist_acro_ordered ~ Lat + Long + MMM + Depth + catBleaching + DHW2020 + maxDHW + Kd_490, data = meta_acro)

sort(vif.cca(ord_acro_full)) 
#catBleaching        Depth       maxDHW      DHW2020         Long          Lat          MMM 
  #  1.275608     1.291015     2.334278     3.436693    15.066787    28.331807    47.078976 

# Reduce the model (consult the corplot and vif scores). We will omit Long and MMM, and latitude will reflect overall biogeographic patterns 
ord_acro <- dbrda(dist_acro_ordered ~ Lat + Depth + catBleaching + DHW2020 + maxDHW + Kd_490, data = meta_acro)

sort(vif.cca(ord_acro)) 
     #  Depth catBleaching       maxDHW      DHW2020          Lat 
    #1.189509     1.242132     1.677445     3.409606     3.756585 

# Use ordistep to run a backward stepwise model. This will reduce the model to the most significant parameters 
os_acro_backward <- ordistep(ord_acro, direction = "backward", permutations = 999)
anova(os_acro_backward, by = 'margin')

# Model: dbrda(formula = dist_acro_ordered ~ Lat + Depth + catBleaching + DHW2020 + maxDHW + Kd_490, data = meta_acro)
  #            Df SumOfSqs       F Pr(>F)    
#Lat            1   0.2633  6.0124  0.001 ** 
#Depth          1   0.1180  2.6937  0.021 *  
#catBleaching   1   0.1001  2.2849  0.042 *  
#DHW2020        1   0.3343  7.6335  0.001 ***
#maxDHW         1   0.6725 15.3567  0.001 ***
#Kd_490         1   0.3074  7.0199  0.001 ***
#Residual     253  11.0795                   

summary(ord_acro)

R2adj <- RsquareAdj(ord_acro)$adj.r.squared
R2adj 
#[1] 0.1608562

#variance partitioning to see how much variation is explained by each factor 
varp <- varpart(dist_acro_ordered, ~Lat, ~Kd_490, ~DHW2020, ~maxDHW, data = meta_acro)
plot(varp, digits = 2, Xnames = c("Lat", "KD 490", "DHW2020", "maxDHW"), bg = c("navy", "tomato", "green", "yellow"))

#extract dbRDA scores
acro_scores <- as.data.frame(scores(os_acro_backward, display = "sites")) %>%
  tibble::rownames_to_column(var = "Vial") %>%
  left_join(., meta_acro)

#extract dbRDA vectors
acro_vectors <- as.data.frame(os_acro_backward$CCA$biplot) %>%
  tibble::rownames_to_column(var = "factors")

#produce dbRDA plot 
acro_fullrda <- acro_scores %>%
  mutate(Reef = fct_relevel(Reef, reef_order)) %>%
    ggplot(aes(x = dbRDA1, y = dbRDA2)) +
      geom_point(aes(fill = Lat), size = 3, shape = 21) +
      geom_label_repel(data = acro_vectors, aes(x = dbRDA1, y = dbRDA2, label = factors), box.padding = 0.75, size = 4, segment.colour = NA) +
      geom_segment(data = acro_vectors, aes(x = 0, xend = dbRDA1, y = 0, yend = dbRDA2), 
      size = 0.5, arrow = arrow(length = unit(0.5, "cm")), colour = "royalblue2") +
        theme(aspect.ratio = 1, text = element_text(size = 15)) +
      scale_fill_viridis_c(option = "magma", direction = -1, guide = guide_colorbar(reverse = TRUE)) +
     theme(legend.position = "right") +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank()) 
     #edit legends


acro_fullrda
```


```{r}
snp.acro <- meta %>%
  filter(mtORF == "Ahumilis") %>%
  filter(sample_name %in% keepers_ss$sample_name) %>%
 # filter(!(sample_name %in% outlier_samples)) %>%
 # tibble::column_to_rownames(var = "Vial") 
  dplyr::select(Vial, Reef, Site, catBleaching, Depth, DHW2020)

save(snp.acro, file = "snp.acro.RData")
```


## Fig 4 dbRDA
```{r}
dbrda <- pmh8_fullrda + pver_fullrda + acro_fullrda 
dbrda

```


# 6 Procrustes Rotation

### Load Data
```{r}
load("clean_data.RData")

seq_data <- clean_data %>% 
  filter(!str_detect(name, "non")) %>% 
  filter(!str_detect(name, "p_"))
  
#creating an object for each species 
poci_seqs.b <- seq_data %>% filter(coral_genus == "Pocillopora")
pver_seqs.b <- seq_data %>% filter(str_detect(mtORF, "Pverrucosa"))
pmh8_seqs.b <- seq_data %>% filter(str_detect(mtORF, "Pmeandrina|Haplotype8a"))
acro_seqs.b <- seq_data %>% filter(str_detect(mtORF, "Ahumilis"))

#code for defining specific colours per reef for procrustes plots later on
reef_pal2 <- c("#ac1917", "#e54a50", "#b75420", "#ea8553", "#c0982b", "#eec76b", "#768b45", "#a9be77", "#B2DFDB", "#6fb293", "#4eaaa6","#1c7873", "#00798C")

reef_names <- c("Osprey", "Bougainville", "Moore", "Willis", "Holmes", "Chilcott", "Herald","Lihou", "Flinders", "Marion", "Frederick", "Saumarez", "Wreck")

names(reef_pal2) <- reef_names
```

```{r}
clust_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
clust_pal <- c("#CB409D", "#FF983B", "#FE4E4E")
names(clust_pal) <- clust_names
```


```{r}
kid_names <- c("C3A", "C3B")
kid_pal <- c("#CB409D", "#FF983B")
names(kid_pal) <- kid_names
```

## Load Metadata
```{r}
meta = read.csv("Metadata.csv") %>% 
  mutate(sample_name = as.factor(sample_name))

```


## Load Kgroup clustering for symbiont genetics
```{r}
poci_dend <- as.dendrogram(hclust_samps_poci)
poci_dend <- color_branches(poci_dend, k = 10, col = ggsci::pal_d3(palette = "category10"))
plot(poci_dend)

poci_k <- data.frame(Vial = labels(poci_dend),
                     k = dendextend::get_leaves_branches_col(poci_dend)) %>%
  mutate(k_id = case_when(k == "#2CA02CFF" ~ "ClatN",
                          k == "#9467BDFF" ~ "ClatS",
                          k == "#8C564BFF" ~ "Cpac",
                          TRUE ~ "outliers")) %>%
  filter(k_id != "outliers") %>%
  left_join(., meta) %>%
  dplyr::select(Vial, k_id, k, Reef, Lat, Long, mtORF)

acro_dend <- as.dendrogram(hclust_samps_acro)
acro_dend <- color_branches(acro_dend, k = 10, col = ggsci::pal_d3(palette = "category10"))
plot(acro_dend)

acro_k <- data.frame(Vial = labels(acro_dend),
                     k = dendextend::get_leaves_branches_col(acro_dend)) %>%
  mutate(k_id = case_when(k == "#D62728FF" ~ "C3A",
                          k == "#9467BDFF" ~ "C3B",
                          TRUE ~ "outliers")) %>%
  filter(k_id != "outliers") %>%
  left_join(., meta) %>%
  dplyr::select(Vial, k_id, k, Reef, Lat, Long, mtORF)

k_map <- rbind(poci_k, acro_k)
```


## 6.1 P. meandrina Procrustes 
```{r}

```

### 6.1.1 P.meandrina  Tree
```{r}


```


### 6.1.2 Subset H and P matrices
```{r, include = FALSE}
library(vegan)

#convert host (H) and symbiont (P) distance trees as data matrices 
H.dist <- dart.pmea.tree %>% as.matrix()
P.dist <- dist_pmh8.b %>% as.matrix()

#must have same number of dimensions 
dim(H.dist)
dim(P.dist)

# Subset to only the samples that are in both datasets
intersect_samples <- intersect(rownames(H.dist), rownames(P.dist))
P.dist_intersect <- P.dist[intersect_samples, ]
H.dist_intersect <- H.dist[intersect_samples, ]

# Check that the samples are now aligned
all(rownames(H.dist_intersect) == rownames(P.dist_intersect))

#re-check dimensions
dim(H.dist_intersect)
dim(P.dist_intersect)

#where is the issue with one extra in H dist? 
setdiff(rownames(H.dist_intersect), rownames(P.dist_intersect))
setdiff(colnames(H.dist_intersect), colnames(P.dist_intersect))

# Identify the column that is missing in P.dist_intersect
missing_col <- setdiff(colnames(H.dist_intersect), colnames(P.dist_intersect))

# Remove the missing column from H.dist_intersect
H.dist_intersect_complete <- H.dist_intersect[, !colnames(H.dist_intersect) %in% missing_col]

# Subset to only the samples that are in both datasets
intersect_samples <- intersect(rownames(H.dist_intersect_complete), rownames(P.dist_intersect))
P.dist <- P.dist_intersect[intersect_samples, ]
H.dist <- H.dist_intersect_complete[intersect_samples, ]

#recheck dimensions - all good 
dim(P.dist)
dim(H.dist)
```


###6.1.3 Perform Paco analysis
```{r, include = FALSE}
# Perform Procrustes analysis. logical that symbionts depend on the host. so X = host and Y = symbiont. 

```


###6.1.4 P. mea procrustes plot
```{r}
#transfer PC coords into dataframe for plotting  



#filter metadata to just reef


#left join the metadata to get reef into the dataframe 


#create plot 


```

###6.1.5 Test significance 
```{r}
#testing significance 
protest(X = H.dist, Y = P.dist, scores = "sites", permutations = 999)
```




# 6.2 P. verrucosa Procrustes 
```{r}


#now must filter fasta files to correspond to samples in seqs_long subset 



#creating the subset symbiont tree


#as a distance matrix


#creating the tree


#subsetting the metadata


#creating unifrac distance matrix and tree 
  #GUniFrac calculates all the distances 


#GUniFrac with alpha 0.5

```


### 6.2.1 P.verrucosa  Tree
```{r}
load("HostAdmix/gl3.csmp.pver.RData")

library(adegenet)

# calculate a distance matrix
dist_matrix_pver <- gl.dist.ind(gl3.csmp.pver, method = "euclidean", scale = TRUE)
# convert the distance matrix to a dist object
dart.pver.tree <- as.dist(dist_matrix_pver)

```


###6.2.2 Subset H and P matrices
```{r}
library(vegan)

#convert host (H) and symbiont (P) distance trees as data matrices 
H.dist.pver <- dart.pver.tree %>% as.matrix()
P.dist.pver <- dist_pver.b %>% as.matrix()

#must have same number of dimensions 
dim(H.dist.pver)
dim(P.dist.pver)

# Subset to only the samples that are in both datasets
intersect_samples.pver <- intersect(rownames(H.dist.pver), rownames(P.dist.pver))
P.dist_intersect.pver <- P.dist.pver[intersect_samples.pver, ]
H.dist_intersect.pver <- H.dist.pver[intersect_samples.pver, ]

# Check that the samples are now aligned
all(rownames(H.dist_intersect.pver) == rownames(P.dist_intersect.pver))

#re-check dimensions
dim(H.dist_intersect.pver)
dim(P.dist_intersect.pver)

#where is the issue with one extra in H dist? 
setdiff(rownames(H.dist_intersect.pver), rownames(P.dist_intersect.pver))
setdiff(colnames(H.dist_intersect.pver), colnames(P.dist_intersect.pver))

# Identify the column that is missing in P.dist_intersect
missing_col.pver <- setdiff(colnames(H.dist_intersect.pver), colnames(P.dist_intersect.pver))
# P ver 379 

# Remove the missing column from H.dist_intersect
H.dist_intersect_complete.pver <- H.dist_intersect.pver[, !colnames(H.dist_intersect.pver) %in% missing_col.pver]

# Subset to only the samples that are in both datasets
intersect_samples.pver <- intersect(rownames(H.dist_intersect_complete.pver), rownames(P.dist_intersect.pver))
P.dist.pver <- P.dist_intersect.pver[intersect_samples.pver, ]
H.dist.pver <- H.dist_intersect_complete.pver[intersect_samples.pver, ]

#recheck dimensions - all good 
dim(P.dist.pver)
dim(H.dist.pver)
```


###6.2.3 Perform Paco analysis
```{r, include = FALSE}
# Perform Procrustes analysis. logical that symbionts depend on the host. so X = host and Y = symbiont 


```


###6.2.4 P. verrucosa procrustes plot
```{r}



```


###6.2.5 Test significance 
```{r}
#testing significance 
protest(X = H.dist.pver, Y = P.dist.pver, scores = "sites", permutations = 999)
```


# 6.3 Acropora humilis procrustes
```{r}
load("HostAdmix/list.acro.RData")
#here is the subset with the data that matches the host dartseq data
seqs_wide_acro_subset.b <- acro_seqs.b %>% 
  filter(Vial %in% c(list.acro))


#now must filter fasta files to correspond to samples in seqs_long subset 
fasta_acro.b <- read_fasta_df("0_SymPortal/186_20211115_03_DBV_20211116T024440.seqs.fasta") %>%
  filter(label %in% seqs_wide_acro_subset.b$name) %>%   
  deframe() %>%
  as_dna()

#creating the subset symbiont tree
kdist_acro.b <- fasta_acro.b %>%
  dna_to_DNAbin() %>%
  kdistance(k = 7, residues = "DNA", method = "edgar") 

#as a distance matrix
kdist_acro.b <- as.matrix(kdist_acro.b)

#creating the tree
k_tree_acro.b <- kdist_acro.b %>% phangorn::upgma()

#subsetting the metadata
seqs_wide_acro.b <- acro_seqs.b[acro_seqs.b$Vial %in% seqs_wide_acro_subset.b$Vial,] %>% 
  dplyr::select(Vial, name, value) %>%
  pivot_wider(names_from = name, values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "Vial")

#creating unifrac distance matrix and tree 
k_unidist_acro.b <- GUniFrac(seqs_wide_acro.b, k_tree_acro.b)   #GUniFrac calculates all the distances 
k_unidist_acro.b <- k_unidist_acro.b$unifracs

#GUniFrac with alpha 0.5
du_acro.b <- k_unidist_acro.b[, , "d_0.5"]    # GUniFrac with alpha 0.5 
dist_acro.b <- as.dist(du_acro.b, diag = FALSE)
```

###6.3.1 Acropora Dartseq Tree
```{r}
load("HostAdmix/gl3.csmp.acro.RData")

library(adegenet)

# calculate a distance matrix
dist_matrix_acro <- gl.dist.ind(gl3.csmp.acro, method = "euclidean", scale = TRUE)
# convert the distance matrix to a dist object
dart.acro.tree <- as.dist(dist_matrix_acro)

```


###6.3.2 Subset H and P matrices
```{r}
library(vegan)

#convert host (H) and symbiont (P) distance trees as data matrices 
H.dist.acro <- dart.acro.tree %>% as.matrix()
P.dist.acro <- dist_acro.b %>% as.matrix()

#must have same number of dimensions 
dim(H.dist.acro)
dim(P.dist.acro)

# Subset to only the samples that are in both datasets
intersect_samples.acro <- intersect(rownames(H.dist.acro), rownames(P.dist.acro))
P.dist_intersect.acro <- P.dist.acro[intersect_samples.acro, ]
H.dist_intersect.acro <- H.dist.acro[intersect_samples.acro, ]

# Check that the samples are now aligned
all(rownames(H.dist_intersect.acro) == rownames(P.dist_intersect.acro))

#re-check dimensions
dim(H.dist_intersect.acro)
dim(P.dist_intersect.acro)

#where is the issue with one extra in H dist? 
setdiff(rownames(H.dist_intersect.acro), rownames(P.dist_intersect.acro))
setdiff(colnames(H.dist_intersect.acro), colnames(P.dist_intersect.acro))

# Identify the column that is missing in P.dist_intersect
missing_col.acro <- setdiff(colnames(H.dist_intersect.acro), colnames(P.dist_intersect.acro))
# P ver 379 

# Remove the missing column from H.dist_intersect
H.dist_intersect_complete.acro <- H.dist_intersect.acro[, !colnames(H.dist_intersect.acro) %in% missing_col.acro]

# Subset to only the samples that are in both datasets
intersect_samples.acro <- intersect(rownames(H.dist_intersect_complete.acro), rownames(P.dist_intersect.acro))
P.dist.acro <- P.dist_intersect.acro[intersect_samples.acro, ]
H.dist.acro <- H.dist_intersect_complete.acro[intersect_samples.acro, ]

#recheck dimensions - all good 
dim(P.dist.acro)
dim(H.dist.acro)
```


```{r}
#create PCoA of H.Dist and P.dist and see their distances along the axes. 

paco.test.P <- cmdscale(P.dist.acro, eig = TRUE)    #this is doing 'cmds' or classic multidimensional scaling
paco.test.H <- cmdscale(H.dist.acro, eig = TRUE) 

ordiplot(paco.test.P)
ordiplot(paco.test.H)

MDSxy.acro.b <- data.frame(pcoa_acro.b$points) %>% 
  rownames_to_column(var = "Vial") %>% 
  left_join(., meta) %>% 
   mutate(catBleaching = as.factor(catBleaching)) %>% 
  filter(!(Vial %in% outlier_samples)) 

```


###6.3.3 Perform Paco analysis
```{r, include = FALSE}
# Perform Procrustes analysis. logical that symbionts depend on the host. so X = host and Y = symbiont 

paco.acro <- procrustes(H.dist.acro, P.dist.acro, symmetric = FALSE)
summary(paco.acro)
#sum of squares here is ridiculous (over 1 million)

#symmetric = FALSE: This specifies that the Procrustes rotation can be non-orthogonal (i.e. generalised), meaning that it can include scaling and shearing transformations in addition to rotation and reflection. This allows for more flexible alignment between the two dissimilarity matrices, but may result in a less interpretable or meaningful alignment depending on the nature of the data.


#check the residuals 
#paco error chart 
plot(paco.acro, kind = 1, type = "text")

#show paco residuals. higher numbers mean these are the samples that have high dissimilarity between the symbiont and host trees
plot(paco.acro, kind = 2, type = "text")
```


### 6.3.4 Acropora procrustes plot
```{r}

```



```{r}
##sub-panel to include only symbionts of the Acropora Procrustes to better see (not overlaid with host points or segments)

```


```{r}
procrust.acro.clust + procrust.acro
```


### 6.3.5 Test significance 
```{r}
#testing significance 
protest(X = H.dist.acro, Y = P.dist.acro, scores = "sites", permutations = 999)
```



#6.5 Fig 3 Procrustes
```{r}
procrust.pmea + procrust.pver + procrust.acro + procrust.acro.sym
```


# 7 dbRDA subset models 

```{r}
#load genetic data from the host genetic models. has the PC1 and PC2 for each species
load("ind_coords.acro.RData")
load("ind_coords.iso.RData")
load("ind_coords.monti.RData")
```


### 7.1 Pmea Hap8 dbRDA subset
```{r}
#metadata for subset of genetic samples 
load("HostAdmix/qlong.pmea.RData")
qlong.pmea <- qlong.pmea %>% dplyr::rename(Vial = Ind)

meta.pmea.admix <- hp.df.pmea %>% left_join(meta) %>% 
  left_join(qlong.pmea) %>% 
  tibble::column_to_rownames(var = "Vial") %>%
  mutate(sample_name = rownames(.))

#importing unifrac distances for analysis 
dist_pmh8_ordered <- dist_subset(dist_pmh8, rownames(meta.pmea.admix))

# Make a correlation matrix of numeric variables
cm <- cor(meta.pmea.admix %>% select(Depth, maxDHW, MMM, DHW2020, Lat, Long))

corrplot(cm) # Clearly a lot of the DHW terms are positively related and approaching redundant

# Check the vif scores of the full model
ord_pmh8_full <- dbrda(dist_pmh8_ordered ~ Lat + Long + MMM + Depth + catBleaching + DHW2020 + maxDHW, data = meta.pmea.admix)

sort(vif.cca(ord_pmh8_full))

   #    Depth catBleaching       admix1       maxDHW      DHW2020          Lat         Long 
   # 1.208572     1.459430     1.547302     3.526390     9.296066    23.277907    28.248336 
  #       MMM 
  # 32.315842 

# Reduce the model (consult the corplot and vif scores)
ord_pmh8 <- dbrda(dist_pmh8_ordered ~  Lat + admix1 + Depth + catBleaching + DHW2020 + maxDHW, data = meta.pmea.admix)

# Re check the new vif scores
sort(vif.cca(ord_pmh8))
     #  Depth catBleaching       admix1       maxDHW      DHW2020          Lat 
   # 1.162181     1.344646     1.531987     1.962000     6.066496     7.006022 

# Use ordistep to further refine the model


#Model: dbrda(formula = dist_pmh8_ordered ~ Lat + admix1 + catBleaching, data = meta.pmea.admix)
           #  Df SumOfSqs       F Pr(>F)    
#Lat           1  0.08199  4.5678  0.006 ** 
#admix1        1  0.30430 16.9522  0.001 ***
#catBleaching  1  0.04080  2.2730  0.063 .  
#Residual     62  1.11291         


#variance partitioning: how much does each variable explain in the model? residuals? 
varp <- varpart(dist_pmh8_ordered, ~admix1, ~Lat, data = meta.pmea.admix)
plot(varp, digits = 2, Xnames = c("admix1", "Lat"), bg = c("navy", "tomato"))

meta.pmea.admix <- meta.pmea.admix %>% 
  tibble::rownames_to_column(var = "Vial")

#extract scores (values assigned to Vials) from dbRDA 


#extract vectors from dbRDA 

#produce dbRDA plot 

```


### 7.1b Pmea Hap8 dbRDA subset
```{r}
#Using host PC1 and PC2 axis to see if better explains variability. 
#metadata for subset of genetic samples 
ind_coords.pmea <- ind_coords.pmea %>% dplyr::rename(Vial = Ind) 
ind_coords.pmea <- ind_coords.pmea %>% dplyr::select(Vial, Axis1, Axis2)

meta.pmea.admix <- hp.df.pmea %>% left_join(meta) %>% 
  left_join(ind_coords.pmea) %>% 
      left_join(., light.data) %>% 
  tibble::column_to_rownames(var = "Vial") %>%
  mutate(sample_name = rownames(.))

#importing unifrac distances for analysis 
dist_pmh8_ordered <- dist_subset(dist_pmh8, rownames(meta.pmea.admix))

# Make a correlation matrix of numeric variables
cm <- cor(meta.pmea.admix %>% select(Depth, maxDHW, MMM, DHW2020, Lat, Long, Axis1, Axis2, Kd_490))

corrplot(cm) # Clearly a lot of the DHW terms are positively related and approaching redundant

# Check the vif scores of the full model
ord_pmh8_full <- dbrda(dist_pmh8_ordered ~ Lat + Long + MMM + Depth + catBleaching + DHW2020 + maxDHW + Axis1 + Axis2 + Kd_490, data = meta.pmea.admix)

sort(vif.cca(ord_pmh8_full))

   #  Axis2        Depth catBleaching        Axis1       maxDHW      DHW2020 
  #  1.049423     1.210745     1.476685     1.577884     3.595913     9.395082 
  #       Lat         Long          MMM 
  # 23.967776    28.161502    33.115062 

# Reduce the model (consult the corplot and vif scores)
ord_pmh8 <- dbrda(dist_pmh8_ordered ~  Lat + Axis1 + Axis2 + Depth + catBleaching + DHW2020 + maxDHW + Kd_490, data = meta.pmea.admix)

# Re check the new vif scores
sort(vif.cca(ord_pmh8))
    #   Axis2        Depth catBleaching        Axis1       maxDHW       Kd_490 
 #   1.042951     1.182727     1.432760     1.582112     1.974544     2.311119 
 #    DHW2020          Lat 
  #  6.196582     7.446101 

# Use ordistep to further refine the model
ord_pmh8_backward <- ordistep(ord_pmh8, direction = "backward", permutations = 999)
anova(ord_pmh8_backward, by = 'margin')


#Model: dbrda(formula = dist_pmh8_ordered ~ Lat + Axis1 + catBleaching + Kd_490, data = meta.pmea.admix)
 #            Df SumOfSqs       F Pr(>F)    
#Lat           1  0.04854  2.9699  0.031 *  
#Axis1         1  0.29342 17.9547  0.001 ***
#catBleaching  1  0.04862  2.9749  0.027 *  
#Kd_490        1  0.04062  2.4857  0.052 .  
#Residual     61  0.99688    


#variance partitioning: how much does each variable explain in the model? residuals? 
varp <- varpart(dist_pmh8_ordered, ~Axis1, ~Lat, ~catBleaching, data = meta.pmea.admix)
plot(varp, digits = 2, Xnames = c("Host PC1", "Lat", "Bleach Condition"), bg = c("navy", "tomato", "green"))

meta.pmea.admix <- meta.pmea.admix %>% 
  tibble::rownames_to_column(var = "Vial")

#extract scores (values assigned to Vials) from dbRDA 
pmh8_scores <- as.data.frame(ord_pmh8_backward$CCA$wa)  %>%
  tibble::rownames_to_column(var = "Vial") %>%
  left_join(., meta.pmea.admix)

#extract vectors from dbRDA 
pmh8_vectors <- as.data.frame(ord_pmh8_backward$CCA$biplot) %>%
  tibble::rownames_to_column(var = "factors")

#produce dbRDA plot 
pmh8_fullrda <- pmh8_scores %>%
 # mutate(Reef = fct_relevel(Reef, reef_order)) %>%
    ggplot(aes(x = dbRDA1, y = dbRDA2)) +
      geom_point(aes(fill = Lat), size = 4, shape = 21) +
        geom_label_repel(data = pmh8_vectors, aes(x = dbRDA1, y = dbRDA2, label = factors), box.padding = 0.5, size = 4, segment.colour = NA) +
      geom_segment(data = pmh8_vectors, aes(x = 0, xend = dbRDA1, y = 0, yend = dbRDA2), 
      size = 0.5, arrow = arrow(length = unit(0.5, "cm")), colour = "royalblue2") +
     guides(fill = guide_colorbar (reverse = T)) +
      scale_fill_viridis_c(option = "magma", direction = -1) +
     theme(legend.position = "none") +
    theme(aspect.ratio = 1, text = element_text(size = 15)) +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank())

pmh8_fullrda
```
**Host PC Axis 1 explains more variation than Admixture (1.2% more) so we will go with using this approach and not the dominant host admixture cluster**


### 7.2 Pver dbRDA subset
```{r}
#metadata for subset of genetic samples 
load("HostAdmix/qlong.pver.RData")
qlong.pver <- qlong.pver %>% dplyr::rename(Vial = Ind)

meta.pver.admix <- hp.df.pver %>% left_join(meta) %>% 
  left_join(qlong.pver) %>% 
        left_join(., light.data) %>% 
  tibble::column_to_rownames(var = "Vial") %>%
  mutate(sample_name = rownames(.))

#importing unifrac distances for analysis 
dist_pver_ordered <- dist_subset(dist_pver.b, rownames(meta.pver.admix))

# Make a correlation matrix of numeric variables
cm <- cor(meta.pver.admix %>% select(Depth, maxDHW, MMM, DHW2020, Lat, Long, Admix1, Kd_490))

#plot the correlation matrix 
corrplot(cm)

# Check the vif scores of the full model
ord_pver_full <- dbrda(dist_pver_ordered ~ Lat + Long + MMM + Depth + catBleaching + DHW2020 + maxDHW + Admix1 + Kd_490, data = meta.pver.admix)



sort(vif.cca(ord_pver_full))

#catBleaching        Depth       Admix1       Kd_490      DHW2020       maxDHW 
  #  1.092418     1.094186     1.166948     1.977137     3.371504     3.778786 
    #    Long          Lat          MMM 
  # 11.460421    18.905643    25.899071 

# Reduce the model (consult the corplot and vif scores)
ord_pver <- dbrda(dist_pver_ordered ~ Lat + Admix1 + Depth + catBleaching + DHW2020 + maxDHW + Kd_490, data = meta.pver.admix)

# Re check the new vif scores
sort(vif.cca(ord_pver))

    #  Depth catBleaching       Admix1       maxDHW       Kd_490          Lat 
  #  1.060456     1.092394     1.129541     1.502577     1.949109     2.802223 
  #   DHW2020 
  #  3.130006 

# Use ordistep to further refine the model
ord_pver_backward <- ordistep(ord_pver, direction = "backward", permutations = 999)
anova(ord_pver_backward, by = 'margin')

#Model: dbrda(formula = dist_pver_ordered ~ Lat + Admix1 + DHW2020 + Kd_490, data = meta.pver.admix)
     #     Df SumOfSqs      F Pr(>F)  
#Lat        1  0.04706 2.1461  0.053 .
#Admix1     1  0.04483 2.0445  0.059 .
#DHW2020    1  0.04884 2.2273  0.043 *
#Kd_490     1  0.06047 2.7574  0.017 *
#Residual 125  2.74110                


#variance partitioning: how much does each variable explain in the model? residuals? 
varp <- varpart(dist_pver_ordered,  ~Admix1, ~Depth, data = meta.pver.admix)
plot(varp, digits = 2, Xnames = c("Admix1", "Depth"), bg = c("navy", "tomato"))

meta.pver.admix <- meta.pver.admix %>% 
  tibble::rownames_to_column(var = "Vial")

#extract scores (values assigned to Vials) from dbRDA 
pver_scores <- as.data.frame(ord_pver_backward$CCA$wa)  %>%
  tibble::rownames_to_column(var = "Vial") %>%
  left_join(., meta.pver.admix)

#extract vectors from dbRDA 
pver_vectors <- as.data.frame(ord_pver_backward$CCA$biplot) %>%
  tibble::rownames_to_column(var = "factors")

#produce dbRDA plot 
pver_fullrda <- pver_scores %>%
 # mutate(Reef = fct_relevel(Reef, reef_order)) %>%
    ggplot(aes(x = dbRDA1, y = dbRDA2)) +
      geom_point(aes(fill = Lat), size = 4, shape = 21) +
      geom_label_repel(data = pver_vectors, aes(x = dbRDA1, y = dbRDA2, label = factors), box.padding = 0.5, size = 4, segment.colour = NA) +
      geom_segment(data = pver_vectors, aes(x = 0, xend = dbRDA1, y = 0, yend = dbRDA2), 
      size = 0.5, arrow = arrow(length = unit(0.5, "cm")), colour = "royalblue2") +
     guides(fill = guide_colorbar (reverse = T)) +
      scale_fill_viridis_c(option = "magma", direction = -1) +
     theme(legend.position = "none") +
    theme(aspect.ratio = 1, text = element_text(size = 15)) +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank())

pver_fullrda
```


### 7.2b Pver dbRDA subset
```{r}
#metadata for subset of genetic samples 
ind_coords.pver <- ind_coords.pver %>% dplyr::rename(Vial = Ind) 
ind_coords.pver <- ind_coords.pver %>% dplyr::select(Vial, Axis1, Axis2)

meta.pver.admix <- hp.df.pver %>% left_join(meta) %>% 
  left_join(ind_coords.pver) %>% 
  left_join(., light.data) %>% 
  tibble::column_to_rownames(var = "Vial") %>%
  mutate(sample_name = rownames(.))

#importing unifrac distances for analysis 
dist_pver_ordered <- dist_subset(dist_pver.b, rownames(meta.pver.admix))

# Make a correlation matrix of numeric variables
cm <- cor(meta.pver.admix %>% select(Depth, maxDHW, MMM, DHW2020, Lat, Long, Axis1, Axis2))

#plot the correlation matrix 
corrplot(cm)

# Check the vif scores of the full model
ord_pver_full <- dbrda(dist_pver_ordered ~ Lat + Long + MMM + Depth + catBleaching + DHW2020 + maxDHW + Axis1 + Axis2 + Kd_490, data = meta.pver.admix)

sort(vif.cca(ord_pver_full))

#catBleaching        Depth        Axis2        Axis1       Kd_490      DHW2020 
 #   1.122876     1.169560     1.292441     1.458919     2.023064     3.395482 
  #    maxDHW         Long          Lat          MMM 
 #   3.525813    11.370598    18.413712    26.043164 

# Reduce the model (consult the corplot and vif scores)
ord_pver <- dbrda(dist_pver_ordered ~ Lat + Axis1 + Axis2 + Depth + catBleaching + DHW2020 + maxDHW + Kd_490, data = meta.pver.admix)

# Re check the new vif scores
sort(vif.cca(ord_pver))
   
#catBleaching        Depth        Axis2       maxDHW        Axis1       Kd_490 
  #  1.122821     1.131462     1.287313     1.443148     1.452954     1.997668 
    #     Lat      DHW2020 
  #  2.846434     3.152849 

# Use ordistep to further refine the model
ord_pver_backward <- ordistep(ord_pver, direction = "backward", permutations = 999)
anova(ord_pver_backward, by = 'margin')

#Model: dbrda(formula = dist_pver_ordered ~ Axis1 + Axis2 + Depth, data = meta.pver.admix)
   #       Df SumOfSqs      F Pr(>F)    
#Model: dbrda(formula = dist_pver_ordered ~ Axis1 + Depth, data = meta.pver.admix)
    #      Df SumOfSqs      F Pr(>F)    
#Axis1      1  0.15396 7.1139  0.001 ***
#Depth      1  0.04393 2.0297  0.059 . 
#Residual 126  2.68879          


#variance partitioning: how much does each variable explain in the model? residuals? 
varp <- varpart(dist_pver_ordered,  ~Axis1, ~Depth, data = meta.pver.admix)
plot(varp, digits = 2, Xnames = c("HostPC1", "Depth"), bg = c("navy", "tomato"))

meta.pver.admix <- meta.pver.admix %>% 
  tibble::rownames_to_column(var = "Vial")

#extract scores (values assigned to Vials) from dbRDA 
pver_scores <- as.data.frame(ord_pver_backward$CCA$wa)  %>%
  tibble::rownames_to_column(var = "Vial") %>%
  left_join(., meta.pver.admix)

#extract vectors from dbRDA 
pver_vectors <- as.data.frame(ord_pver_backward$CCA$biplot) %>%
  tibble::rownames_to_column(var = "factors")

#produce dbRDA plot 
pver_fullrda <- pver_scores %>%
 # mutate(Reef = fct_relevel(Reef, reef_order)) %>%
    ggplot(aes(x = dbRDA1, y = dbRDA2)) +
      geom_point(aes(fill = Lat), size = 4, shape = 21) +
      geom_label_repel(data = pver_vectors, aes(x = dbRDA1, y = dbRDA2, label = factors), box.padding = 0.5, size = 4, segment.colour = NA) +
      geom_segment(data = pver_vectors, aes(x = 0, xend = dbRDA1, y = 0, yend = dbRDA2), 
      size = 0.5, arrow = arrow(length = unit(0.5, "cm")), colour = "royalblue2") +
     guides(fill = guide_colorbar (reverse = T)) +
      scale_fill_viridis_c(option = "magma", direction = -1) +
     theme(legend.position = "none") +
    theme(aspect.ratio = 1, text = element_text(size = 15)) +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank())

pver_fullrda
```



## 7.3 Acro dbRDA subset
**Is recent.maxDHW still an important factor when we account for cryptic speciation of the host?**
```{r}
#metadata for subset of genetic samples 
load("HostAdmix/qlong.acro.RData")
qlong.acro <- qlong.acro %>% 
  select(Vial, Cluster = variable) %>% 
  mutate(Cluster = as.factor(Cluster)) 


meta.acro.admix <- hp.df.acro %>% left_join(meta) %>% 
  left_join(qlong.acro) %>% 
    left_join(., light.data) %>% 
  tibble::column_to_rownames(var = "Vial") %>%
  mutate(sample_name = rownames(.)) %>% 
  filter(!is.na(Cluster))

#importing unifrac distances for analysis 
dist_acro_ordered <- dist_subset(dist_acro, rownames(meta.acro.admix)) 

# Make a correlation matrix of numeric variables to check for collinearity b/w enviro variables 
cm <- cor(meta.acro.admix %>% select(Depth, maxDHW, MMM, DHW2020, Lat, Long))
corrplot(cm) 

# Check the vif scores of the full model
ord_acro_full <- dbrda(dist_acro_ordered ~ Lat + Long + MMM + Depth + catBleaching + DHW2020 + maxDHW + Cluster + Kd_490, data = meta.acro.admix)

sort(vif.cca(ord_acro_full))
#ClusterCluster 2     catBleaching ClusterCluster 3            Depth           Kd_490 
     #   1.140291         1.299252         1.372435         1.488882         1.959612 
     #     maxDHW          DHW2020             Long              Lat              MMM 
      #  3.006738         4.382221        17.411663        30.637018        61.321187 

# Reduce the model (consult the corplot and vif scores)
ord_acro <- dbrda(dist_acro_ordered ~  Lat + Cluster + Depth + catBleaching + DHW2020 + maxDHW + Kd_490, data = meta.acro.admix)

# Re check the new vif scores
sort(vif.cca(ord_acro))
#Cluster 2 ClusterCluster 3     catBleaching            Depth           Kd_490 
    #    1.110087         1.238475         1.256406         1.312395         1.577857 
     #     maxDHW          DHW2020              Lat 
   #     1.962547         4.255033         4.270588 


# Reduce the model (consult the corplot and vif scores)
ord_acro <- dbrda(dist_acro_ordered ~ Lat + Cluster + Depth + catBleaching + DHW2020 + maxDHW + Kd_490, data = meta.acro.admix)

# Use ordistep to further refine the model
ord_acro_backward <- ordistep(ord_acro, direction = "backward", permutations = 999)
anova(ord_acro_backward, by = 'margin')

 #Model: dbrda(formula = dist_acro_ordered ~ Lat + Cluster + Depth + catBleaching + DHW2020 + maxDHW, data = meta.acro.admix)
     #         Df SumOfSqs       F Pr(>F)    
#Lat            1  0.01494  5.4055  0.001 ***
#Cluster        2  0.01075  1.9453  0.038 *  
#Depth          1  0.00888  3.2121  0.021 *  
#catBleaching   1  0.00684  2.4759  0.027 *  
#DHW2020        1  0.02112  7.6438  0.001 ***
#maxDHW         1  0.04052 14.6620  0.001 ***
#Residual     247  0.68262                            


#variance partitioning: how much does each variable explain in the model? residuals? 
varp <- varpart(dist_acro_ordered,  ~Lat, ~Cluster, ~varSST, ~maxDHW, data = meta.acro.admix)
plot(varp, digits = 2, Xnames = c("Lat", "Cluster", "varSST", "maxDHW"), bg = c("navy", "tomato", "orange", "green"))

#extract scores from dbRDA 
meta.acro.admix <- meta.acro.admix %>% 
  tibble::rownames_to_column(var = "Vial")

#extract scores (values assigned to Vials) from dbRDA 
acro_scores <- as.data.frame(ord_acro_backward$CCA$wa)  %>%
  tibble::rownames_to_column(var = "Vial") %>%
  left_join(., meta.acro.admix)

#extract vectors from dbRDA 
acro_vectors <- as.data.frame(ord_acro_backward$CCA$biplot) %>%
  tibble::rownames_to_column(var = "factors")

#produce dbRDA plot 
acro_fullrda <- acro_scores %>%
 # mutate(Reef = fct_relevel(Reef, reef_order)) %>%
    ggplot(aes(x = dbRDA1, y = dbRDA2)) +
      geom_point(aes(fill = Lat), size = 4, shape = 21) +
      geom_label_repel(data = acro_vectors, aes(x = dbRDA1, y = dbRDA2, label = factors), box.padding = 0.5, size = 4, segment.colour = NA) +
      geom_segment(data = acro_vectors, aes(x = 0, xend = dbRDA1, y = 0, yend = dbRDA2), 
      size = 0.5, arrow = arrow(length = unit(0.5, "cm")), colour = "royalblue2") +
     guides(fill = guide_colorbar (reverse = T)) +
      scale_fill_viridis_c(option = "magma", direction = -1) +
     theme(legend.position = "right") +
    theme(aspect.ratio = 1, text = element_text(size = 15)) +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank())

acro_fullrda
```


```{r}
#metadata for subset of genetic samples 
ind_coords.acro <- ind_coords.acro %>% dplyr::rename(Vial = Ind) 
ind_coords.acro <- ind_coords.acro %>% dplyr::select(Vial, Axis1, Axis2)
meta.acro.admix <- hp.df.acro %>% left_join(meta) %>% 
      left_join(., light.data) %>% 
  left_join(ind_coords.acro) %>% 
  tibble::column_to_rownames(var = "Vial") %>%
  mutate(sample_name = rownames(.))


#importing unifrac distances for analysis 
dist_acro_ordered <- dist_subset(dist_acro, rownames(meta.acro.admix)) 

# Make a correlation matrix of numeric variables to check for collinearity b/w enviro variables 
cm <- cor(meta.acro.admix %>% select(Depth, maxDHW, MMM, DHW2020, Lat, Long, Axis1, Axis2, Kd_490))
corrplot(cm) 

# Check the vif scores of the full model
ord_acro_full <- dbrda(dist_acro_ordered ~ Lat + Long + MMM + Depth + catBleaching + DHW2020 + maxDHW + Axis1 + Axis2 + Kd_490, data = meta.acro.admix)

sort(vif.cca(ord_acro_full))
 #     Axis2 catBleaching        Axis1        Depth       Kd_490       maxDHW 
  #  1.160700     1.299017     1.430682     1.459460     2.053633     3.037757 
 #    DHW2020         Long          Lat          MMM 
  #  4.417400    18.882381    30.997679    64.794737 

# Reduce the model (consult the corplot and vif scores)
ord_acro <- dbrda(dist_acro_ordered ~  Lat + Axis1 + Axis2 + Depth + catBleaching + DHW2020 + maxDHW + Kd_490, data = meta.acro.admix)

# Re check the new vif scores
sort(vif.cca(ord_acro))
    #   Axis2        Axis1 catBleaching        Depth       Kd_490       maxDHW 
 #   1.118860     1.225967     1.254304     1.292410     1.608642     1.993583 
 #    DHW2020          Lat 
 #   4.230481     4.237092 

# Reduce the model (consult the corplot and vif scores)
ord_acro <- dbrda(dist_acro_ordered ~ Lat + Axis1 + Axis2 + Depth + catBleaching + DHW2020 + maxDHW + Kd_490, data = meta.acro.admix)

# Use ordistep to further refine the model
ord_acro_backward <- ordistep(ord_acro, direction = "backward", permutations = 999)
anova(ord_acro_backward, by = 'margin')

#Model: dbrda(formula = dist_acro_ordered ~ Lat + Depth + catBleaching + DHW2020 + maxDHW + Kd_490, data = meta.acro.admix)
  #            Df SumOfSqs       F Pr(>F)    
#Lat            1   0.2609  5.9380  0.001 ***
#Depth          1   0.1213  2.7602  0.011 *  
#catBleaching   1   0.1001  2.2791  0.05 *  
#DHW2020        1   0.3341  7.6038  0.001 ***
#maxDHW         1   0.6827 15.5383  0.001 ***
#Kd_490         1   0.3042  6.9230  0.001 ***
#Residual     250  10.9836                                            


#variance partitioning: how much does each variable explain in the model? residuals? 
varp <- varpart(dist_acro_ordered,  ~maxDHW, ~DHW2020, ~Kd_490, ~Lat, data = meta.acro.admix)
plot(varp, digits = 2, Xnames = c("maxDHW", "DHW2020", "KD490", "Lat"), bg = c("navy", "tomato", "orange", "green"))

#extract scores from dbRDA 
meta.acro.admix <- meta.acro.admix %>% 
  tibble::rownames_to_column(var = "Vial")

#extract scores (values assigned to Vials) from dbRDA 
acro_scores <- as.data.frame(ord_acro_backward$CCA$wa)  %>%
  tibble::rownames_to_column(var = "Vial") %>%
  left_join(., meta.acro.admix)

#extract vectors from dbRDA 
acro_vectors <- as.data.frame(ord_acro_backward$CCA$biplot) %>%
  tibble::rownames_to_column(var = "factors")

#produce dbRDA plot 
acro_fullrda <- acro_scores %>%
 # mutate(Reef = fct_relevel(Reef, reef_order)) %>%
    ggplot(aes(x = dbRDA1, y = dbRDA2)) +
      geom_point(aes(fill = Lat), size = 4, shape = 21) +
      geom_label_repel(data = acro_vectors, aes(x = dbRDA1, y = dbRDA2, label = factors), box.padding = 0.5, size = 4, segment.colour = NA) +
      geom_segment(data = acro_vectors, aes(x = 0, xend = dbRDA1, y = 0, yend = dbRDA2), 
      size = 0.5, arrow = arrow(length = unit(0.5, "cm")), colour = "royalblue2") +
     guides(fill = guide_colorbar (reverse = T)) +
      scale_fill_viridis_c(option = "magma", direction = -1) +
     theme(legend.position = "right") +
    theme(aspect.ratio = 1, text = element_text(size = 15)) +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank())

acro_fullrda
```



```{r}
pmh8_fullrda + pver_fullrda + acro_fullrda
```


**Because we see an influence of genetic cluster on the environmental factors, we will look specifically at the main Acropora host cluster to see what environmental drivers are an influence. It is difficult to draw any conclusion from environment when there are interactions b/w where host are, and what environmental patterns they experience** 

##7.4 Acro AHCL1 only dbRDA subset
```{r}
#metadata for subset of genetic samples 
load("HostAdmix/qlong.acroC3.RData")
qlong.acroC3 <- qlong.acroC3 %>% 
  select(Vial = Ind, Admix1)


meta.acroC3.admix <- hp.df.acroC3 %>% left_join(meta) %>% 
  left_join(qlong.acroC3) %>% 
   left_join(., light.data) %>% 
  tibble::column_to_rownames(var = "Vial") %>%
  mutate(sample_name = rownames(.)) 

#importing unifrac distances for analysis 
dist_acroC3_ordered <- dist_subset(dist_acroC3.b, rownames(meta.acroC3.admix)) 

# Make a correlation matrix of numeric variables
cm <- cor(meta.acroC3.admix %>% select(Depth, maxDHW, MMM, DHW2020, Lat, Long, Kd_490))

corrplot(cm) # A lot of the DHW terms are positively related and approaching redundant


# Check the vif scores of the full model
ord_acroC3_full <- dbrda(dist_acroC3_ordered ~ Lat + Long + MMM + Depth + catBleaching + DHW2020 + maxDHW + Kd_490, data = meta.acroC3.admix)


sort(vif.cca(ord_acroC3_full))
#catBleaching        Depth       maxDHW      DHW2020         Long          Lat          MMM 
  #  1.270005     1.316018     2.135333     3.187346    12.420998    22.481312    42.195356 

# Reduce the model (consult the corplot and vif scores)
ord_acroC3 <- dbrda(dist_acroC3_ordered ~ Lat + Kd_490 + Depth + catBleaching + DHW2020 + maxDHW, data = meta.acroC3.admix)

# Re check the new vif scores
sort(vif.cca(ord_acroC3))
#catBleaching        Depth       Kd_490       maxDHW          Lat      DHW2020 
   # 1.229349     1.247731     1.534752     1.764076     3.389785     3.506005 

# Use ordistep to further refine the model
ord_acroC3_backward <- ordistep(ord_acroC3, direction = "backward", permutations = 999)
anova(ord_acroC3_backward, by = 'margin')
             
#Model: dbrda(formula = dist_acroC3_ordered ~ Lat + Kd_490 + Depth + DHW2020 + maxDHW, data = meta.acroC3.admix)
   #       Df SumOfSqs       F Pr(>F)    
#Lat        1  0.01867  5.8986  0.002 ** 
#Kd_490     1  0.01761  5.5643  0.001 ***
#Depth      1  0.00731  2.3098  0.045 *  
#DHW2020    1  0.02061  6.5121  0.001 ***
#maxDHW     1  0.03527 11.1436  0.001 ***
#Residual 192  0.60768               

#variance partitioning: how much does each variable explain in the model? residuals? 
varp <- varpart(dist_acroC3_ordered,  ~Depth, ~maxDHW, ~Lat, ~DHW2020, data = meta.acroC3.admix)
plot(varp, digits = 2, Xnames = c("Depth", "maxDHW", "Lat", "DHW2020"), bg = c("navy", "tomato", "orange", "green"))

#extract scores from dbRDA 
meta.acroC3.admix <- meta.acroC3.admix %>% 
  tibble::rownames_to_column(var = "Vial")

#extract scores (values assigned to Vials) from dbRDA 
acroC3_scores <- as.data.frame(ord_acroC3_backward$CCA$wa)  %>%
  tibble::rownames_to_column(var = "Vial") %>%
  left_join(., meta.acroC3.admix)

#extract vectors from dbRDA 
acroC3_vectors <- as.data.frame(ord_acroC3_backward$CCA$biplot) %>%
  tibble::rownames_to_column(var = "factors")

#produce dbRDA plot 
acroC3_fullrda <- acroC3_scores %>%
    ggplot(aes(x = dbRDA1, y = dbRDA2)) +
      geom_point(aes(fill = Lat), size = 4, shape = 21) +
      geom_label_repel(data = acroC3_vectors, aes(x = dbRDA1, y = dbRDA2, label = factors), box.padding = 0.5, size = 4, segment.colour = NA) +
      geom_segment(data = acroC3_vectors, aes(x = 0, xend = dbRDA1, y = 0, yend = dbRDA2), 
      size = 0.5, arrow = arrow(length = unit(0.5, "cm")), colour = "royalblue2") +
     guides(fill = guide_colorbar (reverse = T)) +
      scale_fill_viridis_c(option = "magma", direction = -1) +
     theme(legend.position = "right") +
    theme(aspect.ratio = 1, text = element_text(size = 15)) +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank()) 

acroC3_fullrda
```


```{r}
#Compaison between full acropora dbRDA (left) and a dbRDA containing only the main host cluster AHCL1
acro_fullrda + acroC3_fullrda
```


```{r}
clust_pal <- c("#768b45", "#a9be77")

clust_names <- c("ClatN", "ClatS")

names(clust_pal) <- clust_names

poci.pie <- poci_k %>% 
  filter(mtORF != "Pverrucosa") %>% 
  filter(k_id != "Cpac") %>% 
  group_by(Reef, k_id) %>% 
  dplyr::summarise(n = n()) %>% 
    group_by(Reef) %>%
  mutate(proportion = n / sum(n) * 100)

poci.pie

ggplot(poci.pie, aes(x = "", y = n, fill = factor(k_id))) +
  geom_bar(position="fill", stat="identity") + coord_polar("y")+
  facet_wrap( ~ Reef) +
  scale_fill_manual(values = clust_pal) +
  theme_classic()+
  theme(legend.position = c(0.8, 0.15), 
        axis.title=element_blank(), 
        axis.line=element_blank(),
        axis.ticks=element_blank(), 
        axis.text=element_blank(),
        plot.background = element_blank(), 
        plot.title=element_text(color="black",size=10,face="plain",hjust=0.5),
        strip.background = element_blank())

```


```{r}
C3prop <- acro_k %>%
  group_by(Reef, k_id) %>%
  summarise(n = n()) %>%
  group_by(Reef) %>%
  mutate(proportion = n / sum(n) * 100)
```

```{r}
meta_acro.heat <- meta_acro %>% select(Reef, maxDHW, recent.maxDHW, DHW2020, Lat, Long) %>% 
    group_by(Reef) %>%
   summarise(
    maxDHW_mean = round(mean(maxDHW), 2),
    recent.maxDHW_mean = round(mean(recent.maxDHW), 2),
    DHW2020_mean = round(mean(DHW2020), 2),
    Lat_mean = round(mean(Lat), 2), 
    Long_mean = round(mean(Long), 2))

C3prop.heat <- C3prop %>% left_join(meta_acro.heat)
```



```{r}
#need to join metadata for Acropora (vial number only) with dominant type profile. Can also extract the dominant sequence. 

prof.data.ahum <- profile_data %>% filter(Species == "Ahumilis") %>% 
  filter(name != "non-profile sequences") %>% 
  dplyr::select(name, value, Vial)

prof.data.ahum %>% distinct(Vial)
#should be 10 samples removed with the next line of code

prof.data.ahum <- prof.data.ahum %>%
  group_by(Vial) %>%
  slice_max(order_by = value)

save(prof.data.ahum, file = "prof.data.ahum.RData")
```